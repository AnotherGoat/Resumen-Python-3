\documentclass{report}

\usepackage[utf8]{inputenc}
\usepackage[a4paper, left=3cm, right=3cm, top=2.5cm, bottom=2.5cm]{geometry}
\usepackage[outputdir=build]{minted}
\usepackage{sectsty}
\usepackage{tocloft}
\usepackage{graphicx}
\usepackage[svgnames]{xcolor}
\usepackage{amsmath}
\usepackage[spanish]{babel}
\usepackage[colorlinks=true, linkcolor=., urlcolor=ForestGreen]{hyperref}

% estilo de los segmentos de código
\usemintedstyle{perldoc}

% colores de capítulos y secciones
\chapterfont{\color{black}}
\sectionfont{\color{DarkBlue}}

% también en la tabla de contenidos
\renewcommand{\cftchapfont}{\bfseries\color{black}}
\renewcommand{\cftsecfont}{\color{black}}

% párrafos sin sangría
\setlength\parindent{0pt}
% separación entre párrafos
\setlength\parskip{1.5ex}

% cambiar espacio entre números y texto en la tabla de contenidos
\setlength\cftchapnumwidth{2em}
\setlength\cftsecnumwidth{3em}

% comandos nuevos para comillas simples y dobles
\newcommand{\simple}[1]{`#1'}
\newcommand{\doble}[1]{``#1''}

% color nuevo para los bloques de código
\definecolor{grisclaro}{RGB}{240, 240, 240}

% macros nuevas para minted
\newmintedfile{python}{bgcolor=grisclaro, frame=single, linenos, numbersep=6pt, breaklines}
\newmintedfile[outfile]{text}{frame=single, linenos, numbersep=6pt, breaklines}
\newmintedfile{text}{frame=single, breaklines}

% para escribir "Salida:" siempre que se muestre el output
\newcommand{\out}[1]{Salida:\outfile{#1}}
% lo mismo pero para entrada
\newcommand{\inp}[1]{Entrada:\outfile{#1}}

% se usan en tablas
\newcommand{\si}{\textcolor{ForestGreen}{Sí}}
\newcommand{\no}{\textcolor{Crimson}{No}}
\newcommand{\noo}{\textcolor{Crimson}{No*}}
\newcommand{\inicio}{\textcolor{DodgerBlue}{Inicio}}
\newcommand{\final}{\textcolor{RoyalBlue}{Final}}
\newcommand{\indices}{\textcolor{ForestGreen}{Índices}}
\newcommand{\claves}{\textcolor{ForestGreen}{Claves}}

\title{Resumen Python 3}
\author{Víctor Mardones Bravo}
\date{Febrero de 2021}

\begin{document}

% la primera hoja no tiene números de página
\pagenumbering{gobble}

% brujería para centrar el título y logo
\null
\nointerlineskip
\vfill
\let\snewpage \newpage
\let\newpage \relax
% se centra el logo svg exportado con Inkscape
  {\centering\def\svgwidth{\columnwidth}
  \input{logo\\python-logo-inkscape.pdf_tex}}
\maketitle
\let \newpage \snewpage
\vfill 
\break

\clearpage

% tabla de contenido
\tableofcontents

\clearpage

% el resto del documento tiene números de página
\pagenumbering{arabic}

\chapter{Introducción a Python}

\section{¿Qué es Python?}

\href{https://www.python.org}{\underline{Python}} es un lenguaje de programación de alto nivel, con aplicaciones en numerosas áreas, incluyendo programación web, scripting, computación científica e inteligencia artificial.

Es muy popular y usado por organizaciones como \href{https://www.google.com}{\underline{Google}}, \href{https://www.nasa.gov}{\underline{la NASA}}, \href{https://www.cia.gov}{\underline{la CIA}} y \href{https://www.disney.com}{\underline{Disney}}.

No hay limitaciones en lo que se puede construir usando Python. Esto incluye aplicaciones autónomas, aplicaciones web, juegos, ciencia de datos, modelos de machine learning y mucho más.

Dato curioso: Según el creador Guido van Rossum, el nombre de Python viene de la serie de comedia británica \doble{El Circo Volador de Monty Python}.

\section{Hola mundo}

Para mostrar el texto \doble{Hola mundo} en pantalla se puede usar la función print().

\pythonfile{codigo/1-intro/hola_mundo_1.py}
\out{codigo/1-intro/hola_mundo_1.out}

Cada declaración de impresión print() genera texto en una nueva línea.

\pythonfile{codigo/1-intro/hola_mundo_2.py}
\out{codigo/1-intro/hola_mundo_2.out}

\section{El Zen de Python}

El Zen de Python es una colección de 19 \doble{principios} para escribir programas de computadores que influenciaron el diseño y representan la filosofía de este lenguaje de programación.

Se mostrará en pantalla la primera vez que se ejecute la siguiente linea, para importar la librería \doble{this}.

\pythonfile{codigo/1-intro/import_this.py}

Después se mostrará el siguiente texto.

\textfile{codigo/1-intro/zen.txt}

%TODO: traducción y mas info

\clearpage\chapter{Conceptos básicos}

\section{Comentarios}

Los comentarios son anotaciones en el código utilizadas para hacerlo más fácil de entender. No afectan la ejecución del código.

En Python, los comentarios comienzan con el símbolo \#. Todo el texto luego de este \# (dentro de la misma línea) es ignorado.

\pythonfile{codigo/2-basico/comentario.py}

Python no soporta comentarios multilínea, al contrario de otros lenguajes de programación.

A lo largo de este resumen, se usarán comentarios para mostrar la salida de algunas funciones, cuando sea posible.

\section{Operaciones aritméticas}

Python tiene la capacidad de realizar cálculos. Los operadores +, -, * y / representan suma, resta, multiplicación y división, respectivamente.

\pythonfile{codigo/2-basico/aritmetica_1.py}
\out{codigo/2-basico/aritmetica_1.out}

Los espacios entre los signos y los números son opcionales, pero hacen que el código sea más fácil de leer.

\section{La regla PEMDAS}

Las operaciones en Python siguen el orden dado por la regla PEMDAS:

\begin{enumerate}
  \item Paréntesis
  \item Exponentes
  \item Multiplicación y división (de izquierda a derecha)
  \item Adición y Sustracción (de izquierda a derecha)
\end{enumerate}

\pythonfile{codigo/2-basico/aritmetica_2.py}
\out{codigo/2-basico/aritmetica_2.out}

\section{Paréntesis}

Se pueden usar paréntesis () para agrupar operaciones y hacer que estas se realicen primero, siguiendo la regla PEMDAS.

\pythonfile{codigo/2-basico/aritmetica_3.py}
\out{codigo/2-basico/aritmetica_3.out}

\section{Floats}
    
Para representar números racionales o que no son enteros, se usa el tipo de dato float o punto flotante. Se pueden crear directamente ingresando un número con un punto decimal, o como resultado de una división.

\pythonfile{codigo/2-basico/float_1.py}
\out{codigo/2-basico/float_1.out}

Se debe tener en cuenta que los computadores \href{http://puntoflotante.org/formats/fp/}{no pueden almacenar perfectamente} el valor de los floats, lo cual a menudo conduce a errores.

\pythonfile{codigo/2-basico/error_float.py}
\out{codigo/2-basico/error_float.py}

El error mostrado arriba es un error clásico de la aritmética de punto flotante. Incluso tiene su propio \href{https://0.30000000000000004.com}{\underline{sitio web}}.

Al trabajar con floats, no es necesario escribir un 0 a la izquierda del punto decimal.

\pythonfile{codigo/2-basico/float_2.py}
\out{codigo/2-basico/float_2.out}

Esta notación se asemeja a decir \doble{punto cinco} en vez de \doble{cero punto cinco}.

El resultado de cualquier operación entre floats o entre un float y un entero siempre dará como resultado un float. La división entre enteros también da como resultado un float.

\pythonfile{codigo/2-basico/float_3.py}
\out{codigo/2-basico/float_3.out}

\section{Exponenciación}

Otra operación soportada es la exponenciación, que es la elevación de un número a la potencia de otro. Esto se realiza usando el operador **.

Ejemplo equivalente a $2 ^ 5 = 32$.

\pythonfile{codigo/2-basico/potencia.py}
\out{codigo/2-basico/potencia.out}

\section{Cociente y resto}

La división entera se realiza usando el operador //, donde el resultado es la parte entera que queda al realizar la división, también conocida como cociente.

La división entera retorna un entero en vez de un float.

\pythonfile{codigo/2-basico/cociente.py}
\out{codigo/2-basico/cociente.out}

Para obtener el resto al realizar una división entera, se debe usar el operador módulo \%.

\pythonfile{codigo/2-basico/resto.py}
\out{codigo/2-basico/resto.out}

Esta operación es equivalente a $7 \mod{2}$ en aritmética modular.

Este operador viene de la \href{https://es.khanacademy.org/computing/computer-science/cryptography/modarithmetic/a/what-is-modular-arithmetic}{aritmética modular}, y uno de sus usos más comunes es para saber si un número es múltiplo de otro. Esto se hace revisando si el módulo al dividirlo por ese otro número es 0.

\pythonfile{codigo/2-basico/uso_del_resto.py}
\out{codigo/2-basico/uso_del_resto.out}

En el caso mostrado anteriormente, se infiere que 10 es múltiplo de 2, que 15 es múltiplo de 3 y que 16 no es múltiplo de 7. El caso particular módulo 2 también puede usarse para saber si un número es par o no.

\clearpage\chapter{Cadenas de texto}

\section{Strings o cadenas de caracteres}

Las cadenas de caracteres se crean introduciendo el texto entre comillas simples \mintinline{python}{' '} o dobles \mintinline{python}{" "}.

\pythonfile{codigo/3-strings/string.py}
\out{codigo/3-strings/string.out}

Un string debe empezar y terminar con comillas del mismo tipo, no se permiten comillas mixtas.

\pythonfile{codigo/3-strings/strings_no_validos.py}
\out{codigo/3-strings/strings_no_validos.out}

\section{Cadena vacía}

A veces es necesario inicializa un string, pero sin agregarle información. Una cadena vacía es definida como \mintinline{python}{''} o \mintinline{python}{""}.

\pythonfile{codigo/3-strings/cadena_vacia.py}

Estos strings vacíos se inicializan en variables, lo cual se verá en el capítulo siguiente.

\section{Caracteres especiales}

Algunos caracteres no se pueden incluir directamente en una cadena. Para esos casos, se debe incluir la barra diagonal inversa \textbackslash antes de ellos.

\pythonfile{codigo/3-strings/caracteres_especiales.py}
\out{codigo/3-strings/caracteres_especiales.out}

Los caracteres $'$, $''$ y \textbackslash son especiales, porque normalmente cumplen funciones especiales dentro de strings.

Si el string se define entre comillas dobles, no es necesario poner \mintinline{python}{'} para ingresar comillas simples dentro de él, y viceversa.

\pythonfile{codigo/3-strings/comillas.py}
\out{codigo/3-strings/comillas.out}

\section{Secuencias de escape}

Las secuencias de escape también se pueden incluir usando el símbolo \textbackslash dentro de cadenas de texto. Su origen viene de las secuencias de escape usadas en las máquinas de escribir.

Algunas de las secuencias de escape más usadas son:
% TODO: mejorar estos ejemplos

\begin{itemize}
  \item Nueva línea (new line): Avanza una línea hacia adelante (salto de línea) y deja el cursor al principio de esta línea (retorno de carro). Representado por \textbackslash n.
  
  \pythonfile{codigo/3-strings/newline.py}
  \out{codigo/3-strings/newline.out}
  
  Cualquier caracter después de \textbackslash n queda en la línea siguiente.

  \item Tabulador horizontal (horizontal tab): Añade un salto de tabulador horizontal. Representado por \textbackslash t.
  
  \pythonfile{codigo/3-strings/tab.py}
  \out{codigo/3-strings/tab.out}
  
  El salto de tabulador avanza hasta el siguiente \doble{tab stop} de la misma línea.

  \item Retorno de carro (carriage return): Mueve el \doble{carro} (cursor) al principio de la línea actual. Esto permite sobreescribir los caracteres escritos anteriormente. Representado por \textbackslash r.
  
  \pythonfile{codigo/3-strings/carriage_return.py}
  \out{codigo/3-strings/carriage_return.out}

  En algunos intérpretes, borra la línea además de volver al inicio.

  \item Retroceso (backspace): Borra el último carácter y mueve el cursor al carácter anterior. Representado por \textbackslash b.
  
  \pythonfile{codigo/3-strings/backspace.py}
  \out{codigo/3-strings/backspace.out}

\end{itemize}

Otras secuencias de escape que cada vez se usan menos son:

\begin{itemize}
  \item Tabulador vertical (vertical tab): Añade un salto de tabulador vertical. Representado por \textbackslash v.
  
  \pythonfile{codigo/3-strings/vtab.py}

  La tabulación vertical avanza hasta la siguiente línea que sea una \doble{tab stop}.

  \item Salto de página (form feed): Baja a la próxima \doble{página}. Representado por \textbackslash f.
  
  \pythonfile{codigo/3-strings/form_feed.py}
  
  Algunos programadores los usaban para separar distintas secciones de código en \doble{páginas}.

\end{itemize}

\section{Caracteres Unicode}

Las barras diagonales inversas también se pueden usar para escribir caracteres Unicode arbitrarios. Se escriben como \textbackslash u seguido del código del carácter Unicode (en hexadecimal).

Los códigos Unicode se aceptan sin importar que tengan mayúsculas o minúsculas.

\pythonfile{codigo/3-strings/unicode.py}
\out{codigo/3-strings/unicode.out}

El \href{https://unicode.org/}{\underline{sitio web de Unicode}} contiene más información sobre estos caracteres y sobre este estándar. \href{https://unicode-table.com/en/}{\underline{Este sitio web}} tiene una tabla con los códigos.

\section{Strings multilínea}

Este es un tipo especial de string, que se escribe entre comillas triples \mintinline{python}{''' '''} o \mintinline{python}{""" """}, y que reconoce los saltos de línea sin necesidad de usar la secuencia \textbackslash n.

\pythonfile{codigo/3-strings/string_multilinea.py}
\out{codigo/3-strings/string_multilinea.out}

\section{Comentarios multilínea}

Los comentarios multilínea no existen formalmente en Python, pero se puede hacer algo parecido usando strings multilínea fuera de lugares donde normalmente se usarían strings.

\pythonfile{codigo/3-strings/comentario_multilinea.py}

La razón por la que esto ocurre es porque estos \doble{comentarios} se usan para producir documentación del código (docstring). Si se ingresan en secciones particulares del código cumplirán su función de documentar, pero el intérprete no impide que se usen fuera de dichas secciones.

Se detallará mejor este uso en el capítulo de funciones.

\section{Concatenación de strings}

Dos o más cadenas se pueden unir una después de la otra, usando un proceso llamado concatenación. Se usa el operador +.

\pythonfile{codigo/3-strings/concatenacion.py}
\out{codigo/3-strings/concatenacion.out}

La concatenación sólo se puede realizar entre strings, no entre cadenas y números.

\pythonfile{codigo/3-strings/error_concatenacion.py}
\out{codigo/3-strings/error_concatenacion.out}

\section{Multiplicación de strings}

Las cadenas también pueden ser multiplicadas por números enteros. Esto produce una versión repetida de la cadena original. El orden de la cadena y el número no importa, pero la cadena suele ir primero.

\pythonfile{codigo/3-strings/multiplicar_cadenas_1.py}
\out{codigo/3-strings/multiplicar_cadenas_1.out}

También se pueden combinar operaciones de multiplicación y concatenación.

\pythonfile{codigo/3-strings/concatenacion_y_multiplicacion.py}

Multiplicar por 0 genera un string vacío.

\pythonfile{codigo/3-strings/multiplicar_cadenas_2.py}
\out{codigo/3-strings/multiplicar_cadenas_2.out}

\section{Opciones del método print()}

El método print() puede aceptar más de un string como argumento, lo cual hace que se muestren en una misma línea separados por espacios.

\pythonfile{codigo/3-strings/print_avanzado_1.py}
\out{codigo/3-strings/print_avanzado_1.out}

El método print() tiene 2 argumentos que pueden definirse para dar más control sobre lo que se imprime en la pantalla.

El argumento sep define el string separador entre cada string \doble{normal} que se le entregue al método print(), excepto después del último. Estos separadores pueden incluir secuencias de escape.

\pythonfile{codigo/3-strings/print_avanzado_2.py}
\out{codigo/3-strings/print_avanzado_2.out}

El argumento end define el string que irá después del último string \doble{normal}. Se puede usar para seguir escribiendo en la misma línea, si no se incluye la secuencia de escape \textbackslash n.

\pythonfile{codigo/3-strings/print_avanzado_3.py}
\out{codigo/3-strings/print_avanzado_3.out}

\pythonfile{codigo/3-strings/print_avanzado_4.py}
\out{codigo/3-strings/print_avanzado_4.out}

Ambos argumentos se pueden combinar.

\pythonfile{codigo/3-strings/print_avanzado_5.py}
\out{codigo/3-strings/print_avanzado_5.out}

\clearpage\chapter{Variables}

\section{Asignación de variables}

Una variable permite almacenar un valor asignándole un nombre, el cual puede ser usado para referirse al valor más adelante en el programa. Para asignar una variable, se usa el signo igual =.

\pythonfile{codigo/4-variables/variable_1.py}

\section{Nombre de variables válidos}

Se aplican ciertas restricciones con respecto a los caracteres que se pueden usar en los nombres de variables. Los únicos caracteres permitidos son letras, números y guiones bajos. Además, no se puede comenzar con números o incluir espacios.

\pythonfile{codigo/4-variables/error_variable_1.py}
\out{codigo/4-variables/error_variable_1.out}

\pythonfile{codigo/4-variables/error_variable_2.py}
\out{codigo/4-variables/error_variable_2.out}

\pythonfile{codigo/4-variables/error_variable_3.py}
\out{codigo/4-variables/error_variable_3.out}

Python es sensible a mayúsculas y minúsculas, lo que significa que las variables \doble{num}, \doble{Num}, \doble{NUM}, etc. son distintas.

\pythonfile{codigo/4-variables/mayusculas_y_minusculas.py}
\out{codigo/4-variables/mayusculas_y_minusculas.out}

\section{Palabras clave}

Existen palabras específicas que tampoco se pueden usar como nombres de variables. El intérprete de Python reconoce estas palabras como palabras clave o keywords, y tienen usos reservados.

A continuación, se muestra una lista de todas las palabras clave en Python.

\textfile{codigo/4-variables/palabras_clave.txt}

Nótese el uso de mayúsculas al principio de False, None y True.

\section{Operaciones con variables}

Se pueden usar variables dentro de operaciones. Lo único que se debe recordar es que deben declararse antes.

\pythonfile{codigo/4-variables/variable_2.py}
\out{codigo/4-variables/variable_2.out}

Una variable también puede cambiar de valor a lo largo de la ejecución de un programa.

\pythonfile{codigo/4-variables/variable_3.py}

\section{Entrada}

Para obtener información del usuario, se puede usar la función input(). La información obtenida puede ser almacenada como una variable.

\pythonfile{codigo/4-variables/input_1.py}
\inp{codigo/4-variables/input_1.inp}
\out{codigo/4-variables/input_1.out}

Toda la información recibida por el método input() es retornada como un string.
También se puede entregar un string como parámetro al método input(), lo cual mostrará texto antes de pedir la entrada. Esto sirve para aclarar qué entrada está solicitando el programa.

\pythonfile{codigo/4-variables/input_2.py}

Al usar la función input(), el flujo del programa se detiene hasta que el usuario ingrese algún valor.

\section{Conversión de tipos de datos}

Existen funciones para convertir datos de un tipo a otro. Entre dichas funciones se encuentran:

\begin{itemize}
  \item int(): Convierte a un número entero.
  
  \pythonfile{codigo/4-variables/convertir_a_int.py}
  \out{codigo/4-variables/convertir_a_int.out}

  Aunque ambos se impriman igual, el primero es un string y el segundo un entero (int).

  \item float(): Convierte a un float.
  
  \pythonfile{codigo/4-variables/convertir_a_float.py}
  \out{codigo/4-variables/convertir_a_float.out}

  \item str(): Convierte a un string o cadena de caracteres. Uno de sus usos principales es para concatenar distintos tipos de datos.

  \pythonfile{codigo/4-variables/convertir_a_string.py}
  \out{codigo/4-variables/convertir_a_string.out}

\end{itemize}

\section{Operadores de asignación}

Los operadores de asignación permiten escribir código como \simple{x = x + 1} de manera más concisa, como \simple{x += 1}. Lo mismo es posible con otros operadores como -, *, /, //, \% y **.

\pythonfile{codigo/4-variables/asignacion_1.py}

También se pueden usar con los operadores de concatenación y multiplicación de strings.

\pythonfile{codigo/4-variables/asignacion_2.py}

\clearpage\chapter{Declaraciones if}

\section{Booleanos}

Otro tipo de dato en Python es el tipo booleano, el cual sólo puede tener 2 valores: True y False. Estos se escriben empezando con mayúscula, al contrario de otros lenguajes de programación.

Se pueden crear directamente, aunque esto no tiene mucha utilidad en la mayoría de casos.

\pythonfile{codigo/5-if/booleano_1.py}
\out{codigo/5-if/booleano_1.out}

Su uso más común es como el resultado obtenido al comparar valores, por ejemplo, usando el operador de igualdad ==.

\pythonfile{codigo/5-if/booleano_2.py}
\out{codigo/5-if/booleano_2.out}

En Python, 1 y True significan lo mismo. Lo mismo ocurre con 0 y False.

\pythonfile{codigo/5-if/booleano_3.py}
\out{codigo/5-if/booleano_3.out}

Usando otros términos, podría decirse que 1 es \href{https://stackoverflow.com/questions/39983695/what-is-truthy-and-falsy-how-is-it-different-from-true-and-false}{\doble{truthy}} y que 0 es \href{https://stackoverflow.com/questions/39983695/what-is-truthy-and-falsy-how-is-it-different-from-true-and-false}{\doble{falsy}}.

\section{Operadores de comparación}

Los operadores de comparación usados en Python son los siguientes:

%TODO: nombres
\begin{itemize}
  \item Igual $=$ (escrito como ==): Se evalúa como True si ambos elementos son iguales.
  \item Distinto $\neq$ (escrito como !=): Se evalúa como True si ambos elementos son distintos.
  \item Mayor que $>$: Se evalúa como True si el primer elemento es mayor.
  \item Menor que $<$: Se evalúa como True si el primer elemento es menor.
  \item Mayor o igual que $\geq$ (escrito como >=): Se evalúa como True si el primer elemento es mayor o igual al segundo.
  \item Menor o igual que $\leq$ (escrito como <=): Se evalúa como True si el primer elemento es menor o igual al segundo.
\end{itemize}

En los casos contrarios, los operadores retornan False.

Ejemplos de uso de operadores de comparación:

\pythonfile{codigo/5-if/comparacion_1.py}
\out{codigo/5-if/comparacion_1.out}
%TODO: todos los "out" listos hasta aquí

También se conocen como operadores relacionales.

Las comparaciones entre datos de tipo entero y float también son válidas.

\pythonfile{codigo/5-if/comparacion_2.py}

Las comparaciones entre números y strings son válidas, pero siempre se evalúan como False.

\pythonfile{codigo/5-if/comparacion_3.py}

\section{Declaración if}

Las declaraciones if sirven para ejecutar código si ser cumple una determinada condición. Si la expresión se evalúa como True, se lleva a cabo el bloque de código que le sigue. En caso contrario, no ocurre nada.

\pythonfile{codigo/5-if/if_1.py}

Python usa indentación (espacio en blanco al comienzo de una línea) para delimitar bloques de código. En otros lenguajes, esta operación se realiza delimitando cada bloque de código por llaves {}.

\section{Declaración if-else}

Las declaraciones if-else son muy similares a las declaraciones if, pero esta vez sí ocurre algo cuando no se cumple la expresión a evaluar.

\pythonfile{codigo/5-if/if_2.py}

\pythonfile{codigo/5-if/if_3.py}

\section{Declaración elif}

El término elif se usa cuando se encadenan múltiples declaraciones if-else. Hace que el código sea más corto.

\pythonfile{codigo/5-if/if_4.py}

El programa irá evaluando cada expresión una por una hasta que alguna se cumpla. Cuando esto ocurra, ejecutará las instrucciones en su bloque de código y continuará con las expresiones después del bloque de código else.

\section{Operadores lógicos}

Los operadores lógicos se utilizan para crear condiciones complejas agrupando condiciones más simples. Los operadores lógicos que se usan en Python son and, or y not.

El operador and se evalúa como True si ambas condiciones se cumplen.

\pythonfile{codigo/5-if/and.py}

El operador or se evalúa como True si al menos una de las condiciones se cumple.

\pythonfile{codigo/5-if/or.py}

El operador not sólo toma una condición y la invierte.

\pythonfile{codigo/5-if/not.py}

\section{Precedencia de operadores lógicos}

Los operadores lógicos siguen un orden similar a PEMDAS, el cual es el siguiente:

\begin{enumerate}
  \item Paréntesis
  \item Operador not
  \item Operador and
  \item Operador or
\end{enumerate}

Sin embargo, este orden es confuso, por lo que se recomienda usar paréntesis para hacerlo más obvio.

\pythonfile{codigo/5-if/logica.py}

\clearpage\chapter{Listas}

\section{Creación de listas}

Las listas se utilizan para almacenar varios elementos. Se crean utilizando corchetes y separando los elementos por comas.

\pythonfile{codigo/6-listas/lista_1.py}

En Python, las listas pueden tener elementos de más de un tipo.

\pythonfile{codigo/6-listas/lista_2.py}

\section{Indexación de listas}

Se puede acceder a un determinado elemento de la lista utilizando su índice entre corchetes. El índice del primer elemento es 0, en lugar de 1, como podría esperarse.

\pythonfile{codigo/6-listas/indexar_listas_1.py}

Alternativamente, se pueden usar índices negativos. El último elemento de una lista tiene índice -1, y va disminuyendo hasta llegar al primero.

\pythonfile{codigo/6-listas/indexar_listas_2.py}

\section{IndexError en listas}

Intentar acceder a un índice no existente producirá un error.

\pythonfile{codigo/6-listas/error_indice.py}

\section{Lista vacía}

A veces es necesario crear una lista vacía y completarla más tarde durante la ejecución del programa. Las listas vacías se crean con un par de corchetes vacíos.

\pythonfile{codigo/6-listas/lista_vacia.py}

\section{Anidación de listas}

Las listas se pueden anidar dentro de otras listas, y para acceder a algún elemento se debe usar una cantidad mayor de corchetes, donde los índices indican el elemento desde afuera hacia adentro.

\pythonfile{codigo/6-listas/anidacion.py}

En el ejemplo de arriba se muestra como acceder a todos los elementos de la lista creada.

Las listas anidadas se pueden utilizar para representar cuadrículas 2D, como por ejemplo matrices.

\pythonfile{codigo/6-listas/identidad.py}

\section{Comas sobrantes}

Se puede dejar a lo más una coma sobrante dentro de los corchetes de una lista. Este último elemento no será añadido a la lista.

\pythonfile{codigo/6-listas/comas.py}

\section{Operaciones con listas}

El elemento en un índice determinado de una lista se puede reasignar.

\pythonfile{codigo/6-listas/operaciones_listas_1.py}

Las listas se pueden agregar y multiplicar de la misma manera que las cadenas.

\pythonfile{codigo/6-listas/operaciones_listas_2.py}

\section{Operadores in y not in}

Se puede verificar si un elemento pertenece a una lista usando el operador in. Este devuelve True si dicho elemento aparece una o más veces en la lista y False si no es así.

\pythonfile{codigo/6-listas/in.py}

Para comprobar si un elemento no pertenece a una lista, se pueden combinar los operadores in y not. Ambas formas de hacerlo son válidas.

\pythonfile{codigo/6-listas/not_in.py}

\section{Funciones de listas}

Existen métodos que sirven para trabajar con listas.

\begin{itemize}
  \item El método append() se usa para añadir un elemento al final de una lista.
  
  \pythonfile{codigo/6-listas/append.py}

  \item El método pop() elimina el último elemento de una lista.
  
  \pythonfile{codigo/6-listas/pop_1.py}
  %TODO: Investigar más usos de pop() y otros métodos

  \item El método len() retorna el tamaño (número de elementos) de una lista.
  
  \pythonfile{codigo/6-listas/len.py}

  \item El método insert() se usa para insertar un elemento en un índice específico de una lista. Los elementos que están después del elemento insertado se desplazan a la derecha.

  \pythonfile{codigo/6-listas/insert.py}

  \item El método extend() se usa para añadir todos los elementos de una lista al final de otra lista.
  
  \pythonfile{codigo/6-listas/extend.py}

  \item El método index() encuentra la primera aparición de un elemento en una lista y devuelve su índice. Si el elemento no está en la lista, muestra un ValueError.
  
  \pythonfile{codigo/6-listas/index.py}

  \item El método count() cuenta la cantidad de ocurrencias de un elemento en una lista.
  
  \pythonfile{codigo/6-listas/count.py}

  \item El método remove() elimina la primera ocurrencia de un elemento en una lista.
  
  \pythonfile{codigo/6-listas/remove_1.py}

  Una forma más segura de usar remove() es la siguiente:

  \pythonfile{codigo/6-listas/remove_2.py}

  \item Los métodos max() y min() devuelven el elemento de una lista con valor máximo o mínimo, respectivamente.

  \pythonfile{codigo/6-listas/max_y_min_1.py}

  Si son strings, los compara por orden alfabético. Se considera como \doble{mayor} a las palabras que se encuentran al final después de ordenarlas alfabéticamente.

  \pythonfile{codigo/6-listas/max_y_min_2.py}

  \item El método sum() calcula la suma de los elementos de una lista.
  
  \pythonfile{codigo/6-listas/sum.py}

  \item El método reverse() invierte los elementos de una lista.
  
  \pythonfile{codigo/6-listas/reverse.py}

  \item El método sort() ordena alfabéticamente una lista de strings, por defecto se realiza ascendentemente. Para realizar el orden descendentemente, se debe entregar el parámetro reverse=True.
  
  \pythonfile{codigo/6-listas/sort_letras.py}
  
  También funciona con listas compuestas de números.

  \pythonfile{codigo/6-listas/sort_numeros.py}

  \item El método clear() quita todos los elementos de una lista.

  \pythonfile{codigo/6-listas/clear.py}

\end{itemize}

\section{Copiar listas}

Al intentar copiar listas sólo usando su nombre, en realidad se está haciendo una lista que hace referencia a la lista copiada. Esto significa que los cambios que reciba una lista también los recibirá la otra.

\pythonfile{codigo/6-listas/copy_1.py}

Para evitar esto, se puede usar el método copy() para hacer una copia de una lista en una nueva instancia.

\pythonfile{codigo/6-listas/copy_2.py}

\section{Strings como listas}

%TODO: explicar que los strings son en realidad listas de caracteres

\section{Indexación de strings}

Algunos tipos de variables, como las cadenas, se pueden indexar como listas. La indexación de cadenas se comporta como si estuviera indexando una lista que contiene cada carácter de la cadena.

\pythonfile{codigo/6-listas/strings_como_listas.py}

Se debe recordar que el espacio $''$ $''$ también es considerado como símbolo y tiene su índice dentro de la cadena.

\section{Conversión de strings a listas}

El método list() convierte una cadena de caracteres en una lista de caracteres.

\pythonfile{codigo/6-listas/list.py}

El método split() convierte una cadena de caracteres en una lista de palabras, separadas por espacios “ “.

\pythonfile{codigo/6-listas/split.py}

%TODO: mover el split avanzado a otro capítulo

Al método split() también se le puede entregar un string separador. La lista será formada con los elementos entre cada aparición de ese string.

\pythonfile{codigo/6-listas/split_avanzado.py}

\clearpage\chapter{Bucles}

\section{Bucles while}

Un bucle while se usa para repetir un bloque de código varias veces, siempre que se cumpla cierta condición. Generalmente se usan con una variable como contador.

\pythonfile{codigo/7-bucles/while_1.py}

El código en el cuerpo de un bucle while se ejecuta repetidamente. Esto se llama iteración.

%TODO: while puede hacer otros cambios a las variables

\section{Bucles infinitos}

Si la condición a evaluar es siempre verdadera, el bucle se ejecutará indefinidamente. Esto se llama bucle infinito.

\pythonfile{codigo/7-bucles/while_infinito.py}

No se recomienda ejecutar este código. Si por algún motivo se ejecuta, se puede interrumpir su ejecución enviando un KeyboardInterrupt al usar la combinación de teclas Ctrl+C.

\section{Declaración break}

Para finalizar un bucle while prematuramente, se puede usar la declaración break.

\pythonfile{codigo/7-bucles/break.py}

El uso de la declaración break fuera de un bucle provoca un error.

\pythonfile{codigo/7-bucles/error_break.py}

\section{Declaración continue}

Otra declaración que se puede utilizar dentro de los bucles es continue. A diferencia de break, continue salta de nuevo a la parte superior del bucle, en lugar de detenerlo. Básicamente, la declaración continue detiene la iteración actual y continúa con la siguiente.

\pythonfile{codigo/7-bucles/continue.py}

Al igual que la declaración break, usar continue fuera de un bucle provoca un error.

\pythonfile{codigo/7-bucles/error_continue.py}

\section{Bucle for con listas}

Los bucles for se pueden usar para iterar sobre una lista. Las instrucciones dentro de su bloque de código se ejecutarán para cada elemento de la lista.

\pythonfile{codigo/7-bucles/for_1.py}

También se puede usar para iterar sobre cadenas.

\pythonfile{codigo/7-bucles/for_2.py}

De manera similar a los bucles while, las declaraciones break y continue se pueden utilizar en los bucles for para detener el bucle o saltar a la siguiente iteración.

\pythonfile{codigo/7-bucles/for_3.py}

\section{Rangos}

La función range() devuelve una secuencia de números. De forma predeterminada, comienza desde 0, se incrementa en 1 y se detiene antes del número especificado.

Si se llama a range() con un argumento, produce un objeto con valores desde 0 a el número antes de ese argumento.

%TODO: separar
\pythonfile{codigo/7-bucles/range_1.py}

Para mostrar los números dentro de un objeto range, debe convertirse a una lista.

Si se llama con 2 argumentos, produce valores desde el primero hasta antes del segundo.

\pythonfile{codigo/7-bucles/range_2.py}

\pythonfile{codigo/7-bucles/range_3.py}

El rango puede tener un tercer argumento, que determina el intervalo de la secuencia producida, también llamado como paso. Este número puede ser positivo (incremento) o negativo (decremento).

\pythonfile{codigo/7-bucles/range_4.py}

\section{Bucle for en rangos}

Una forma común de usar los bucles for es iterando sobre rangos. Esto permite hacer bucles de muchas formas.

\pythonfile{codigo/7-bucles/for_rango.py}

No es necesario llamar list() en el objeto de rango cuando se usa en un bucle for, porque no se está indexando, por lo que no requiere una lista.

%iterables

\clearpage\chapter{Funciones}

\section{¿Qué es una función?}

Cualquier sentencia que consista de una palabra seguida de información entre paréntesis es llamada una función.

Ejemplos de funciones que se han visto anteriormente.

\pythonfile{codigo/8-funciones/funciones.py}

\section{Definición de funciones}

Para definir una función, se debe usar la palabra clave def, seguida del nombre de la función y de un paréntesis que puede o no incluir parámetros. El cuerpo de la función incluye el código y debe tener un grado de indentación mayor que el de la definición.

Algunos ejemplos de funciones:

\pythonfile{codigo/8-funciones/saludar.py}

\pythonfile{codigo/8-funciones/exclamar.py}

Una función puede pedir más de un argumento, los cuales deben separarse por comas.

\pythonfile{codigo/8-funciones/sumar.py}

\pythonfile{codigo/8-funciones/mayor.py}

Los argumentos de funciones pueden ser utilizados como variables dentro de la definición de la función. Sin embargo, no pueden ser referenciados fuera de la definición de la función. Esto también se aplica a las demás variables creadas dentro de una función.

\section{Llamado de funciones}

Para llamar una función, debe escribirse su nombre, seguido de un paréntesis que contiene los argumentos (información) que se le quieren entregar.

Ejemplos de uso de las funciones definidas anteriormente:

\pythonfile{codigo/8-funciones/llamar_funciones.py}

\section{Devolución de valores en una función}

Ciertas funciones devuelven un valor para ser utilizado más adelante. Para hacer esto en la definición de funciones nuevas, se debe usar la palabra clave return.

\pythonfile{codigo/8-funciones/return_1.py}

Cualquier código luego de la sentencia return nunca ocurrirá.

\pythonfile{codigo/8-funciones/return_2.py}

\section{Docstring}

Las docstring (cadenas de documentación) cumplen un propósito similar al de los comentarios, pero son más específicos y tienen una sintaxis distinta.

Son creados colocando una cadena multilínea que contenga una explicación de la función por debajo de la primera línea de la función.

\pythonfile{codigo/8-funciones/docstring_1.py}

A diferencia de los comentarios convencionales, los docstring se conservan a lo largo del tiempo de ejecución del programa. Esto le permite al programado examinar estos comentarios en el tiempo de ejecución.

Una forma de accederlo es usando la variable \_\_doc\_\_.

\pythonfile{codigo/8-funciones/print_doc.py}

Otra forma es usando la función help(). Esto entrega un poco más de información.

\pythonfile{codigo/8-funciones/help.py}

Normalmente se usan docstrings para explicar los parámetros y lo que retorna una función.

\pythonfile{codigo/8-funciones/docstring_2.py}

\section{Funciones como objetos}

Aunque sean creadas de manera diferente que las variables regulares, las funciones son como cualquier otra clase de valor. Pueden ser asignadas y reasignadas a variables, y luego ser referenciadas por esos nombres.

\pythonfile{codigo/8-funciones/funcion_como_objeto_1.py}

Las funciones también pueden ser usadas como argumentos de otras funciones.

\pythonfile{codigo/8-funciones/funcion_como_objeto_2.py}

\section{Sobrecarga de funciones}

En Python, la sobrecarga de funciones se define como la habilidad de que una función se comporte de distinta manera dependiendo del número de argumentos que reciba. Esto permite reutilizar el mismo código, reducir su complejidad y hacer que sea más fácil de leer.

Para sobrecargar una función, se deben definir los parámetros que sean opcionales con un valor por defecto None. Después, se usan declaraciones if-elif-else para revisar todos los casos posibles.

\pythonfile{codigo/8-funciones/sobrecarga_1.py}

\pythonfile{codigo/8-funciones/sobrecarga_2.py}

\section{Anotaciones de tipos}

Una anotación de tipos es, como su nombre lo dice, una notación opcional que especifica el tipo de los parámetros de una función y su tipo de retorno.

\pythonfile{codigo/8-funciones/anotaciones_1.py}

En el ejemplo de arriba, se muestra que mensaje es un parámetro de tipo string y que la función duplicar() retorna un string.

Esto le permite al programador saber qué tipos de datos se le deben entregar una función y que tipos de datos esperar cuando esta función retorne.

Las anotaciones de tipos son ignoradas completamente por el intérprete de Python. No restringen el tipo de los parámetros o del retorno de una función, pero son muy útiles al momento de documentar.

\pythonfile{codigo/8-funciones/anotaciones_2.py}

Aunque el intérprete de Python los ignore, existen algunos IDEs y programas que pueden analizar código que contiene anotaciones de tipos y alertar sobre problemas potenciales.

\section{El objeto None}

El objeto None es utilizado para representar la ausencia de un valor. Es similar a null en otros lenguajes de programación.

Al igual que otros valores \doble{vacíos}, tales como (), [], \{\} y la cadena vacía $''$$''$, es False cuando es convertido a una variable booleana.



%TODO: ejemplo y mencionar estructuras de datos

Cuando es ingresado a la consola de Python, se visualiza como una cadena vacía.

\pythonfile{codigo/16-iterables/None_1.py}

El objeto None es devuelto por cualquier función que no devuelve explícitamente algo más.

\pythonfile{codigo/16-iterables/None_2.py}

\clearpage\chapter{Módulos y la biblioteca estándar}

\section{Módulos}

Los módulos son pedazos de código que otras personas han escrito para cumplir tareas comunes tales como generar números aleatorios, realizar operaciones matemáticas, etc.

La manera básica de utilizar un módulo es agregar una declaración import en la parte superior del código, y luego usar su nombre para acceder a las funciones y variables dentro del módulo.

\pythonfile{codigo/9-modulos/ejemplo_modulos.py}

Este ejemplo importa el módulo random y usa su función randint() para generar 5 números aleatorios en el rango del 1 al 6.

Hay otra clase de import que puede ser utilizada si sólo necesitas ciertas funciones de un módulo.

\pythonfile{codigo/9-modulos/import_1.py}

Para importar más de un elemento, se debe hacer una lista separada por comas.

\pythonfile{codigo/9-modulos/import_2.py}

\section{Error de importación}

Importar un módulo que no está disponible dará un ImportError.

\pythonfile{codigo/9-modulos/error_import.py}

\section{Alias}

Se puede importar un módulo u objeto bajo un nombre distinto utilizando la palabra clave as y entregándole un alias. Esto se usa principalmente cuando un módulo u objeto tiene un nombre largo o confuso.

\pythonfile{codigo/9-modulos/alias_1.py}

También se puede usar un alias con más de un objeto.

\pythonfile{codigo/9-modulos/alias_2.py}

\section{La biblioteca estándar}

Hay 3 tipos principales de módulos en Python: aquellos que escribes tú mismo, aquellos que se instalan de fuentes externas y aquellos que vienen preinstalados con Python.

El último tipo se denomina la biblioteca estándar, y contiene muchos módulos útiles. Algunos de estos módulos son:

\textfile{codigo/9-modulos/biblioteca_estandar.txt}

La extensa biblioteca estándar de Python es una de sus principales fortalezas como lenguaje. Se puede encontrar más información sobre los módulos de la biblioteca estándar en \href{https://docs.python.org/3/library/index.html}{\underline{la documentación}}.

Algunos de los módulos en la biblioteca estándar están escritos en Python y otros en C. La mayoría están disponibles en todas las plataformas, pero algunos son específicos de Windows o Unix.

\section{Módulos externos y pip}

Muchos módulos de Python creados por terceros son almacenados en el índice de paquetes Python (Python Package Index, PyPI). Se puede ver el repositorio en su \href{https://pypi.org}{\underline{sitio web oficial.}}

La mejor manera de instalar estos es utilizando un programa llamado pip. Este viene instalado por defecto con las distribuciones modernas de Python.

Para instalar una biblioteca, se debe buscar su nombre, ir a la línea de comandos y escribir pip install nombre.

\textfile{codigo/9-modulos/pip_1.txt}

Es importante recordar que los comandos de pip se deben introducir en la línea de comandos, no en el interpretador de Python.

Se puede ingresar el comando pip help para ver información sobre otros comandos que se pueden usar con este gestor de paquetes.

\textfile{codigo/9-modulos/pip_2.txt}

Utilizar pip es la forma estándar de instalar bibliotecas en la mayoría de sistemas operativos, pero algunas bibliotecas tienen binarios predefinidos para Windows. Estos son archivos ejecutables regulares que permiten instalar bibliotecas con una interfaz gráfica de la misma manera que se instalan otros programas.

\clearpage\chapter{El módulo math}

\clearpage\chapter{El módulo random}

\clearpage\chapter{Manejo de excepciones}

\section{Excepciones}

Se han mencionado excepciones en las secciones anteriores. Ocurren cuando algo sale, mal, debido a código incorrecto o entradas incorrectas. Cuando ocurre una excepción, el programa se detiene inmediatamente.

Al intentar dividir por 0, se produce un ZeroDivisionError.

\pythonfile{codigo/11-excepciones/excepcion_1.py}

Otras excepciones comunes son:

\begin{itemize}
  \item ImportError: Cuando falla una importación.
  \item IndexError: Cuando se intenta indexar una lista con un número fuera de rango.
  \item NameError: Cuando una variable desconocida es utilizada.
  \item SyntaxError: Cuando el código no puede ser analizado correctamente.
  \item TypeError: Cuando una función es llamada con un valor de tipo inapropiado
  \item ValueError: Cuando una función es llamada con un valor del tipo correcto, pero con un valor incorrecto.
\end{itemize}

Las bibliotecas creadas por terceros a menudo definen sus propias excepciones.

\section{Declaración try-except}

Para manejar excepciones y ejecutar código cuando ocurre una excepción, se puede usar una sentencia try-except. El bloque try contiene código que puede lanzar una excepción. Si ocurre una excepción, el código en el bloque try deja de ser ejecutado y el código en el bloque except se ejecuta. Si no ocurre ningún error, el código en el bloque except no se ejecuta.

\pythonfile{codigo/11-excepciones/excepcion_2.py}

Una sentencia try puede tener varios bloques except para manejar diferentes excepciones. Varias excepciones pueden ser colocadas dentro de un mismo bloque except utilizando paréntesis.

\pythonfile{codigo/11-excepciones/excepcion_3.py}

Una sentencia except sin ninguna excepción especificada atrapa todos los errores. Estos deben usarse con moderación ya que pueden atrapar errores inesperados y esconder errores de programación.

\pythonfile{codigo/11-excepciones/excepcion_4.py}

Si una sentencia except vacía viene acompañada de otros except, esta debe ir al final, para evitar atrapar errores esperados.

\section{Declaración finally}

Para asegurar que algún código se ejecute sin importar cuál error ocurra, se puede usar la palabra clave finally. La sentencia finally se coloca en el fondo de una sentencia try-except. El código dentro de la sentencia finally siempre se ejecuta después del código del bloque try y de cualquier bloque except que se ejecute.

\pythonfile{codigo/11-excepciones/finally_1.py}

El código dentro del bloque finally se ejecutará incluso si una excepción sin atrapar ocurre en alguno de los bloques que lo preceden.

\pythonfile{codigo/11-excepciones/finally_2.py}

\section{Levantar excepciones}

Se puede usar la sentencia raise para levantar excepciones. Se necesita especificar el tipo de la excepción levantada.

\pythonfile{codigo/11-excepciones/raise_1.py}

Las excepciones pueden ser levantadas con argumentos que den detalles sobre ellas.

\pythonfile{codigo/11-excepciones/raise_2.py}

\pythonfile{codigo/11-excepciones/raise_3.py}

En los bloques except, la sentencia raise puede ser utilizada sin argumentos para volver a levantar cualquier excepción que haya ocurrido.

\pythonfile{codigo/11-excepciones/raise_4.py}

\section{Aserciones}

Una aserción es una comprobación de validez, la cual prueba una expresión. La expresión es probada, y si el resultado es falso, usa excepción AssertionError es levantada.

Las aserciones son llevadas a cabo a través de la declaración assert.

\pythonfile{codigo/11-excepciones/assert_1.py}

Los programadores a menudo colocan aserciones al principio de una función para asegurarse de que la entrada sea válida, y luego de llamar una función para revisar la validez de la salida.

La declaración assert puede recibir un segundo argumento el cual es pasado a la excepción AssertionError levantada si la aserción falla.

\pythonfile{codigo/11-excepciones/assert_1.py}

Las excepciones AssertionError pueden ser atrapadas y manejadas como cualquier otra excepción utilizando la sentencia try-except, pero si no son manejadas, este tipo de excepción terminará el programa.

En general, se recomienda usar aserciones para atrapar tus propios errores y excepciones para atrapar los errores que los usuarios u otras personas podrían cometer.

\pythonfile{codigo/11-excepciones/assert_2.py}

\clearpage\chapter{Pruebas unitarias}

\clearpage\chapter{Manejo de archivos}

\section{Abrir archivos}

Python se puede usar para leer y escribir los contenidos de archivos. Los archivos de texto son los más fáciles de manipular.
Antes de que un archivo pueda ser editado, debe ser abierto con la función open().

\pythonfile{codigo/14-archivos/open.py}

El argumento de la función open es la ruta del archivo. Si el archivo se encuentra en el directorio hábil actual del programa, se puede especificar sólo su nombre (ruta relativa).

\section{Modos de apertura}

Se puede especificar el modo utilizado para abrir un archivo al pasar un segundo argumento a la función open().

Los modos de apertura son:

\begin{itemize}
  \item \doble{r}: Significa modo de lectura, el cual es el modo predeterminado.
  
  \pythonfile{codigo/14-archivos/modo_r.py}

  \item \doble{w}: Significa modo de escritura, el cual sirve para reescribir los contenidos de un archivo. Abrir un archivo en este modo inmediatamente borra todos sus contenidos.
  
  \pythonfile{codigo/14-archivos/modo_w.py}

  \item \doble{x}: Significa modo de creación, se usa para crear un fichero y escribir sobre él. Entrega un error FileExistsError si el archivo ya existe o no está vacío.
  
  \pythonfile{codigo/14-archivos/modo_x.py}

  \item \doble{a}: significa modo de anexo, para agregar nuevo contenido al final de un archivo.

  \pythonfile{codigo/14-archivos/modo_a.py}

\end{itemize}

Además de los modos de apertura, también existen los modos en los que se muestra la información:

\begin{itemize}
  \item \doble{t}: significa abrir el archivo en modo texto (predeterminado). No es necesario escribirlo.
  \item \doble{b}: significa abrir el archivo en modo binario, que es utilizado para archivos que no son de texto (tales como archivos de imágenes o sonido). Se debe combinar con alguno de los modos anteriores.

  \pythonfile{codigo/14-archivos/modo_b.py}

\end{itemize}

\section{Extensión de modos de apertura}

Se puede añadir el signo \doble{+} a cualquiera de los modos de arriba para darles acceso adicional a archivos.

La siguiente tabla muestra el funcionamiento de cada modo:

% tabla 1

\begin{center}
  \begin{tabular}{ |c|c|c|c|c|c|c|c|c| }
    \hline
    & r & r+ & w & w+ & x & x+ & a & a+ \\
    \hline
    Lee el archivo & \si & \si & \no & \si & \no & \si & \no & \si \\
    \hline
    Escribe en el archivo & \no & \si & \si & \si & \si & \si & \si & \si \\
    \hline
    Crea el archivo si no existe & \no & \no & \si & \si & \si & \si & \si & \si \\
    \hline
    Borra todos los contenidos del archivo & \no & \no & \si & \si & \noo & \noo & \no & \no \\
    \hline
    Posición del cursor & \inicio & \inicio & \inicio & \inicio & \inicio & \inicio & \final & \final \\
    \hline
  \end{tabular}
\end{center}

*: Levanta una excepción FileExistsError.

\section{Cierre de archivos}

Una vez que un archivo haya sido abierto y utilizado, es un buen hábito cerrarlo. Esto se logra con el método close() de un objeto archivo.

\pythonfile{codigo/14-archivos/close.py}

A nivel de sistemas operativos, cada proceso tiene un límite en la cantidad de archivos que puede abrir simultáneamente. Si un programa se ejecuta por mucho tiempo y podría abrir muchos archivos, se debe tener cuidado.

\section{Lectura de archivos}

Los contenidos de un archivo que ha sido abierto en modo texto pueden ser leídos utilizando el método read().

\pythonfile{codigo/14-archivos/read_1.py}

Para leer sólo una determinada parte de un archivo, se puede proveer un número como argumento a la función read(). Esto determina el número de bytes que deberían ser leídos.

Se pueden hacer más llamadas a read() en el mismo objeto archivo para leer más de él byte por byte. Si no se le pasan argumentos, o si el argumento es negativo, read() devuelve el resto del archivo.

\pythonfile{codigo/14-archivos/read_2.py}

El ejemplo de arriba primero mostrará los bytes del 1 al 16, después del 17 al 24, del 25 al 28, y del 29 al último byte.

Luego de que todos los contenidos de un archivo hayan sido leídos, cualquier intento de leer más de ese archivo devolverá una cadena vacía $''$$''$ porque se está intentando leer desde el final del archivo.

\pythonfile{codigo/14-archivos/read_3.py}

Usando el método seek(), se puede mover el \doble{cursor} (puntero) al principio del archivo.

\pythonfile{codigo/14-archivos/seek.py}

El método tell() entrega la posición actual del puntero.

\pythonfile{codigo/14-archivos/tell.py}

Para obtener cada línea de un archivo, se puede usar la función readlines() para devolver una lista donde cada elemento es una línea del archivo.

\pythonfile{codigo/14-archivos/readlines.py}

Esto también se puede hacer usando un bucle for.

\pythonfile{codigo/14-archivos/for_readlines.py}

\section{Escritura de archivos}

Para escribir sobre archivos se utiliza el método write(), el cual escribe una cadena en un archivo.

\pythonfile{codigo/14-archivos/write_1.py}

Cuando un archivo es abierto en modo de escritura, el contenido existente del archivo es borrado.

\pythonfile{codigo/14-archivos/write_2.py}

Para evitar que esto ocurra, se puede usar el modo anexo \doble{a}.

\pythonfile{codigo/14-archivos/write_3.py}

El método write() devuelve el número de bytes escritos en un archivo, si su llamada es exitosa.

\pythonfile{codigo/14-archivos/write_4.py}

Para escribir algo que no sea un string, necesita ser convertido primero a un string.

\pythonfile{codigo/14-archivos/write_5.py}

\section{Declaración with}

Es buena práctica evitar gastar recursos asegurándose de que los archivos sean siempre cerrados después de utilizarlos. Una forma de hacer esto es utilizando try-finally.

\pythonfile{codigo/14-archivos/close_seguro.py}

Esto asegura que el archivo sea siempre cerrado incluso si ocurre un error.
Sin embargo, existe una forma más cómoda de hacer esto usando declaraciones with.

Una forma alternativa de trabajar con archivos es utilizando declaraciones with. Esto crea una variable temporal (a menudo llamada f), la cual solo es accesible en el bloque indentado de la declaración with.

\pythonfile{codigo/14-archivos/with_1.py}

El archivo se cierra automáticamente al final de la declaración with, incluso si ocurren excepciones dentro de ella.

Comparado con la forma tradicional de trabajar con archivos (open-close), usar with tiene el inconveniente de que los archivos tienen que volverse a abrir cada vez que se quiera trabajar con ellos.

Así, una forma más segura de trabajar con archivos puede tener la siguiente estructura:

\pythonfile{codigo/14-archivos/with_2.py}

\clearpage\chapter{Módulos time y datetime}

\clearpage\chapter{Estructuras de datos}

\section{Diccionarios}

%TODO: Método keys()

Los diccionarios son estructuras de datos utilizadas para mapear claves arbitrarias a valores. Pueden ser indexados de la misma manera que las listas, utilizando corchetes que contengan claves.

\pythonfile{codigo/16-iterables/diccionarios_1.py}

Cada elemento de un diccionario es representado por un par clave:valor (key:value). Estos elementos no se almacenan con algún orden en específico. Los diccionarios no están ordenados, lo que significa que no pueden ser indexados por índices, sólo por claves.

Las listas pueden ser consideradas como diccionarios con claves de números enteros dentro de un cierto rango.

\pythonfile{codigo/16-iterables/diccionarios_2.py}

Un diccionario puede almacenar como valor cualquier tipo de datos.

\pythonfile{codigo/16-iterables/diccionarios_3.py}

Tratar de indexar una clave que no es parte de un diccionario retorna un KeyError.
Un diccionario vacío es definido como {}.

\pythonfile{codigo/16-iterables/diccionario_vacio.py}

Sólo objetos inmutables pueden ser utilizados como claves de diccionario. Los objetos inmutables son aquellos que no pueden ser cambiados. Algunos objetos mutables son listas, conjuntos y diccionarios. Tratar de utilizar un objeto mutable como clave de diccionario ocasiona un TypeError.

\section{Indexación de diccionarios}

Al igual que las listas, las claves de un diccionario pueden ser asignadas a distintos valores. Sin embargo, a diferencia de las listas, se le puede asignar un valor a nuevas claves, no sólo a las que ya existen.

\pythonfile{codigo/16-iterables/diccionarios_4.py}

\section{Uso de in y not en diccionarios}

Para determinar si una clave está en un diccionario, se puede usar los operadores in y not in, al igual que en listas.

\pythonfile{codigo/16-iterables/diccionarios_5.py}

Nótese que retorna False al buscar \doble{tres}. Esto ocurre porque \doble{tres} es un valor, no una clave.

\section{Función get()}

Un método útil de diccionarios es get(). Hace lo mismo que indexar, pero si una clave no es encontrada en el diccionario entonces devuelve otro valor especificado (\simple{None} por defecto).

\pythonfile{codigo/16-iterables/get.py}

En este caso es importante recordar que 1 y True son la misma clave. Entonces, el diccionario \doble{pares} sólo tiene 3 elementos (la clave True tendrá como valor False, su último valor).

\pythonfile{codigo/16-iterables/diccionarios_6.py}

\section{Función keys()}

\section{Tuplas}

Las tuplas son estructuras de datos muy parecidas a las listas, excepto que son inmutables (no pueden ser cambiadas). También se crean utilizando paréntesis en vez de corchetes.

\pythonfile{codigo/16-iterables/tupla_1.py}

%TODO: mencionar truco de igualdad

Se puede acceder a los valores de una tupla utilizando su índice. Funciona de la misma forma que con listas.

\pythonfile{codigo/16-iterables/tupla_2.py}

Tratar de reasignar un valor a una tupla ocasiona un TypeError.

\pythonfile{codigo/16-iterables/tupla_3.py}

Al igual que las listas y diccionarios, las tuplas pueden ser anidadas entre sí.
Las tuplas son inmutables, pero el contenido de elementos mutables dentro de ellas puede ser cambiado.

\pythonfile{codigo/16-iterables/tupla_4.py}

Las tuplas pueden \doble{empaquetarse} o \doble{desempaquetarse}, lo que puede ser útil al momento de crear variables.

\pythonfile{codigo/16-iterables/tupla_5.py}

Las tuplas pueden ser creadas sin paréntesis, simplemente separando los valores por comas.

\pythonfile{codigo/16-iterables/tupla_6.py}

Una tupla vacía se crea utilizando un par de paréntesis vacíos.

\pythonfile{codigo/16-iterables/tupla_vacia.py}

Las tuplas son más rápidas que las listas, pero no pueden ser modificadas.

%TODO: mover el último mensaje más arriba y separar esta sección

\section{Conjuntos}

Los conjuntos son estructuras de datos parecidas a las listas o a los diccionarios. Son creandos utilizando llaves o la función set(). Comparten algunas de las funcionalidades de las listas, como el uso de in para revisar si contienen o no un elemento en particular.

\pythonfile{codigo/18-conjuntos/conjuntos.py}

Para crear un conjunto vacío, se debe utilizar set(), ya que {} crea un diccionario vacío.

\pythonfile{codigo/18-conjuntos/conjunto_vacio.py}

Los conjuntos difieren de las listas de varias formas, pero comparten varias operaciones de listas como len().

No están ordenados, lo cual significa que no pueden ser indexados. No pueden tener elementos duplicados.

Debido a la forma en que son almacenados, es más rápido revisar si un elemento es parte de un conjunto que si es parte de una lista.

En lugar de utilizar append() para agregarle algo al conjunto, se utiliza add(). El método remove() elimina un elemento específico de un conjunto.

\pythonfile{codigo/18-conjuntos/add_y_remove.py}

El método pop() elimina un elemento arbitrario. Esto significa que debido a la forma en la Python implementa conjuntos, no hay garantía de que los elementos se retornarán en el mismo orden que en el que se añadieron.

Generalmente, elimina el primer elemento, pero esto no se puede garantizar.

\pythonfile{codigo/18-conjuntos/pop_conjuntos.py}

Usos básicos de conjuntos incluyen pruebas de membresía y la eliminación de entradas duplicadas.

\section{Operaciones con conjuntos}

Los conjuntos pueden ser combinados utilizando operaciones matemáticas.

El operador de unión | combina dos conjuntos para formar uno nuevo que contiene los elementos de cualquiera de los dos.

\pythonfile{codigo/18-conjuntos/union.py}

El operador de intersección \& obtiene sólo los elementos que están en ambos.

\pythonfile{codigo/18-conjuntos/interseccion.py}

El operador de diferencia - obtiene los elementos que están en el primer conjunto, pero no en el segundo.

\pythonfile{codigo/18-conjuntos/diferencia.py}

El operador de diferencia simétrica \^ obtiene los elementos que están en cualquiera de los conjuntos, pero no en ambos.

\pythonfile{codigo/18-conjuntos/diferencia_simetrica.py}

\section{Estructuras de datos}

%TODO: encontrar qué hacer con esta sección

Como se ha visto en capítulos anteriores, Python tiene soporte de las siguientes estructuras de datos: listas, diccionarios, tuplas y conjuntos.

¿Cúando utilizar diccionarios?

\begin{itemize}
  \item Cuando se necesita utilizar asociaciones lógicas entre pares clave:valor.
  \item Cuando se necesita buscar datos rápidamente, en base a claves personalizadas.
  \item Cuando los datos son constantemente modificados.
\end{itemize}

¿Cúando utilizar listas?

\begin{itemize}
  \item Cuando se tiene un grupo de datos que no necesita acceso aleatorio (deben estar ordenados).
  \item Cuando se necesita una recolección simple e iterable que es modificada frecuentemente.
\end{itemize}

¿Cúando utilizar conjuntos?

\begin{itemize}
  \item Cuando se necesita que los elementos sean únicos.
\end{itemize}

¿Cúando utilizar tuplas?

\begin{itemize}
  \item Cuando se necesita almacenar datos que no pueden ser cambiados.
\end{itemize}

En muchas ocasiones, una tupla es utilizada junto con un diccionario. Por ejemplo, una tupla puede representar una clave, porque es inmutable.

La siguiente tabla muestra las propiedades de cada estructura de datos.

% tabla 2

\begin{center}
  \begin{tabular}{ |c|c|c|c|c| }
    \hline
    & Lista & Diccionario & Tupla & Conjunto \\
    \hline
    Mutable & \si & \si & \no & \si \\
    \hline
    Indexado & \indices & \claves & \indices & \no \\
    \hline
    Secuencial & \si & \no & \si & \no \\
    \hline
    Elementos únicos & \no & \no & \no & \si \\
    \hline
    Notación & [ ] & \{ \} & ( ) & \{ \} \\
    \hline
  \end{tabular}
\end{center}

\clearpage\chapter{Manejo de iterables}

\section{Cortes de lista}

Los cortes de lista ofrecen una manera más avanzada de obtener valores de una lista. Los cortes de lista básicos involucran indexar una lista con dos enteros separados por dos puntos. Esto devuelve una lista nueva que contiene todos los valores de la lista vieja entre los índices.

\pythonfile{codigo/16-iterables/cortes_1.py}

Como los argumentos de range, el primer índice provisto en un corte es incluido en el resultado, pero el segundo no.

Si el primer número en un corte es omitido, se toma el principio de la lista. Si el segundo número es omitido, se toma el final de la lista.

\pythonfile{codigo/16-iterables/cortes_2.py}

Los cortes de lista también pueden tener un tercer número, representando el incremento, para incluir valores alternativos en el corte.

\pythonfile{codigo/16-iterables/cortes_3.py}

Los valores negativos pueden ser utilizados en un corte de lista. Cuando los valores negativos son utilizados para el primer y el segundo valor del corte, estos cuentan desde el final de la lista.

\pythonfile{codigo/16-iterables/cortes_4.py}

El tamaño de paso también puede ser negativo, lo que permite usarlos para invertir listas sin usar el método reverse().

\pythonfile{codigo/16-iterables/cortes_reverse.py}

Es importante recordar que si el tamaño de paso es negativo, el primer número debe indicar un índice mayor que el segundo.

\section{Cortes de tuplas}

Los cortes también pueden ser realizados en tuplas. Su funcionamiento es el mismo que con listas.

\pythonfile{codigo/16-iterables/cortes_en_tuplas.py}

Esto es válido porque si bien las tuplas son inmutables, los cortes no realizan ningún cambio sobre los objetos con los que trabajan. Sólo consultan información de cierta manera.

\section{Subcadenas}

En Python pueden usarse cortes para obtener trozos de una cadena. Esto es lo que otros lenguajes de programación realizan usando el método substring(). Funciona de la misma forma que con listas y tuplas.

\pythonfile{codigo/16-iterables/substring_1.py}
%TODO: más

\section{Listas por compresión}

Las listas por compresión son una forma útil de crear rápidamente listas cuyo contenido obedece una regla sencilla.

\pythonfile{codigo/16-iterables/compresion_1.py}

Las listas por compresión son inspiradas por la notación de constructores de conjuntos en las matemáticas.

Una lista por compresión también puede contener una sentencia if para aplicar una condición en los valores de la lista.

\pythonfile{codigo/16-iterables/compresion_2.py}

Intentar crear una lista de rango demasiado extenso resultará en un MemoryError. Es posible que la operación tarde unos minutos en llegar a esta excepción.

\pythonfile{codigo/16-iterables/compresion_3.py}

Este problema es resuelto con generadores, los cuales se verán más tarde.

\section{Formateo de cadenas}

La forma más básica de combinar cadenas y objetos que no son cadenas es convirtiendo dichos objetos a cadenas y concatenando las cadenas.

El formateo de cadenas ofrece una manera más potente de incorporar objetos que no son cadenas a las cadenas. El formateo de cadenas utiliza el método format de una cadena para sustituir los argumentos de esta.

Una forma de hacerlo es usando índices.

\pythonfile{codigo/16-iterables/formateo_1.py}

Cada argumento de la función de formateo es colocada en la cadena de la posición correspondiente, que es determinada usando llaves {}.

Los índices entre llaves {} pueden repetirse cuantas veces se quiera.

\pythonfile{codigo/16-iterables/formateo_2.py}

Si se omite un índice, habrá algún argumento de format() que no se usará.

\pythonfile{codigo/16-iterables/formateo_3.py}

No es necesario escribir los índices dentro de las llaves {}, pero esto no permite que se repitan o que se entreguen como argumentos en otro orden.

\pythonfile{codigo/16-iterables/formateo_4.py}

El formateo de cadenas también puede hacerse con argumentos con nombre.

\pythonfile{codigo/16-iterables/formateo_5.py}

\section{Funciones de cadenas}

Python contiene muchas funciones integradas y métodos útiles que sirven para cumplir tareas comunes. Algunos métodos que se pueden usar con strings son:

\begin{itemize}
  \item join(): Combina una lista de cadenas con otra cadena como separador.
  
  \pythonfile{codigo/16-iterables/join.py}

  \item replace(): Reemplaza una subcadena de una cadena por otra cadena.

  \pythonfile{codigo/16-iterables/replace.py}

  \item startswith(): Determina si hay una subcadena al principio de una cadena.

  \pythonfile{codigo/16-iterables/startswith.py}

  \item endswith(): Determina si hay una subcadena al final de una cadena.
  
  \pythonfile{codigo/16-iterables/endswith.py}

  \item A diferencia de otros lenguajes de programación, Python no tiene el método contains(), para ver si una subcadena pertenece a un string.
  
  Usar el operador in tiene el mismo efecto que tendría dicha función.

  %TODO: contains (if x in string)

  \item upper(): Cambia una cadena a mayúsculas.
  
  \pythonfile{codigo/16-iterables/upper.py}

  \item lower(): Cambia una cadena a minúsculas.
  
  \pythonfile{codigo/16-iterables/lower.py}

  \item capitalize(): Cambia una cadena para que la primera letra sea mayúscula y el resto minúsculas.

  \pythonfile{codigo/16-iterables/capitalize.py}
  
  \item title(): Cambia una cadena para que todas las palabras empiecen con mayúscula.
  
  \pythonfile{codigo/16-iterables/title.py}

\end{itemize}

\section{Funciones numéricas}

Para obtener la distancia entre un número y el 0 (su valor absulto), puede usarse la función abs().

\pythonfile{codigo/16-iterables/abs.py}

Para redondear un número a un determinado número de decimales, puede usarse la función round().

\pythonfile{codigo/16-iterables/round.py}

\section{Funciones all() y any()}

All y any son utilizados con frecuencia como sentencias condicionales. Estos toman una lista como un argumento y devuelven True si todos o algunos (respectivamente) de sus argumentos son evaluados como True (o, de lo contrario, False).

\pythonfile{codigo/16-iterables/all_y_any.py}

%TODO: separar ejemplos

\section{Función enumerate()}

La función enumerate() se usa para iterar a través de los valores e índices de una lista, simultáneamente.

\pythonfile{codigo/16-iterables/enumerate_1.py}

También se puede especificar el índice desde el que comienza.

\pythonfile{codigo/16-iterables/enumerate_2.py}

\clearpage\chapter{Programación funcional}

\section{Paradigma de programación funcional}

La programación funcional es un estilo de programación que, como dice su nombre, gira en torno a funciones.

Una parte clave de la programación funcional son las funciones de orden superior. Similar al uso de funciones como objetos, las funciones de orden superior reciben otras funciones como argumentos, o las devuelven como resultado.

\pythonfile{codigo/17-funcional/ejemplo_funcional.py}

La función repetir2veces() recibe otra función como su argumento y llama 2 veces dentro de su cuerpo.

Entender los conceptos de programación funcional requiere un conocimiento básico del concepto algebraico llamado \href{https://www.mathsisfun.com/sets/functions-composition.html}{\doble{composición de funciones}}.

\section{Funciones puras}

La programación funcional busca utilizar funciones puras. Las funciones puras no tienen efectos secundarios y devuelven un valor que depende únicamente de sus argumentos.

Así son las funciones en las matemáticas. Por ejemplo, la función cos(x) siempre devolverá un mismo resultado para el mismo valor de x.

Ejemplo de función pura:

\pythonfile{codigo/17-funcional/pura.py}

Ejemplo de función impura:

\pythonfile{codigo/17-funcional/impura.py}

Dicho de otra forma, una función pura cumple lo siguiente:

\begin{itemize}
  \item Depende sólo de sus argumentos y de variables locales creadas dentro de ella.
  
  \item Siempre retorna el mismo resultado para los mismos argumentos.

  \item Se puede ejecutar en cualquier parte del programa sin causar efectos secundarios de ningún tipo.
  
  \item No altera ningún elemento fuera de ella.
  
  \item Puede usarse en otros programas y entrega los mismos resultados.
\end{itemize}

Utilizar funciones puras tiene sus ventajas y desventajas.

Las funciones puras son:

\begin{itemize}
  \item Más fáciles de analizar y probar.
  
  \item Más eficientes. Una vez que la función haya sido evaluada para una entrada, el resultado puede ser almacenado y referenciado para la próxima vez que la función con esa entrada sea necesaria, reduciendo el número de veces que la función es llamada. Esto se denomina memorización.
  
  \item Más fáciles de ejecutar en paralelo.
\end{itemize}

Desventajas principales:

\begin{itemize}
  \item Complican en su mayor parte la normalmente sencilla tarea de Entrada/Salida, ya que requiere de efectos secundarios inherentemente.
  
  \item En algunas situaciones, pueden ser más difíciles de escribir.
\end{itemize}

\section{Lambdas}

Crear una función normalmente (utilizando def) le asigna una variable automáticamente.

Esto es distinto a la creación de otros objetos, tales como cadenas y enteros, que pueden ser creados en el camino, sin la necesidad de asignarles una variable.

Lo mismo es posible con las funciones, dado que sean creadas utilizando la sintaxis lambda. Funciones creadas de esta forma son conocidas como anónimas.
Este enfoque es más comúnmente utilizado cuando se pasa una función sencilla como argumento de otra función.

La sintaxis que se muestra a continuación consiste de la palabra reservada lambda seguida de una lista de argumentos, dos puntos, y una expresión a evaluar y devolver.

\pythonfile{codigo/17-funcional/lambda_1.py}

Las funciones lambda reciben su nombre del \href{https://es.wikipedia.org/wiki/C%C3%A1lculo_lambda}{cálculo lambda}, el cual es un modelo computacional inventado por Alonzo Church.
Las funciones lambda no son tan potentes como las funciones con nombre. Sólo pueden hacer cosas que requieren de una sola expresión, normalmente equivalente a una sola línea de código.

\pythonfile{codigo/17-funcional/lambda_2.py}

Las funciones lambda pueden ser asignadas a variables y ser utilizadas como funciones regulares.

\pythonfile{codigo/17-funcional/lambda_3.py}

Sin embargo, rara vez existe una buena razón para hacer esto. Normalmente es mejor definir una función con def.

\section{Función map()}

La función map() es una función de orden superior muy útil que opera sobre listas (u objetos similares llamados iterables).

Esta función recibe una función y un iterable como argumentos y devuelve un nuevo iterable con la función aplicada a cada argumento.

\pythonfile{codigo/17-funcional/map_1.py}

El mismo resultado se puede obtener con mayor facilidad utilizando la sintaxis lambda.

\pythonfile{codigo/17-funcional/map_2.py}

Los objetos del tipo mapa son iterables, por lo que se debe usar list() para convertir el resultado en una lista y poder verlo.

\section{Función filter()}

La función filter() es otra función de orden supero que se puede usar sobre iterables.

Esta función filtra un iterable eliminando elementos que no coincidan con el predicado (una función que devuelve un booleano).

\pythonfile{codigo/17-funcional/filter.py}

Al igual que map(), el resultado tiene que ser convertido explícitamente a una lista si se quiere imprimir.

\section{Generadores}

Los generadores son un tipo de iterable, como las listas o las tuplas.

A diferencia de las listas, no permiten indexar con índices arbitrarios, pero pueden aún ser iterados con bucles for.

Pueden ser creados utilizando funciones y la sentencia yield.

\pythonfile{codigo/17-funcional/generador_1.py}

%TODO: más ejemplos

La sentencia yield es utilizada para definir un generador, reemplazando el retorno de una función para proveer un resultado a su llamador sin destruir las variables locales.

Debido al hecho que yield produce un elemento a la vez, los generadores no tienen las restricciones de memoria de las listas. De hecho, ¡pueden ser infinitos!

\pythonfile{codigo/17-funcional/generador_2.py}

En resumen, los generadores permiten declarar una función que se comporta como un iterador. En otras palabras, que puede utilizarse en un bucle for.

Un ejemplo de uso de generadores es para generar números primos.

\pythonfile{codigo/17-funcional/generador_de_primos.py}

Los generadores finitos pueden ser convertidos en listas al pasarlos como argumentos de la función list().

\pythonfile{codigo/17-funcional/generador_a_lista.py}

Utilizar generadores resulta en un mejor rendimiento, el cual es el resultado de una generación ociosa de valores (a medida que se vayan necesitando), lo cual se traduce en un uso reducido de memoria. Es más, no necesitamos esperar hasta que todos los elementos sean generados antes de empezar a utilizarlos.

\section{Decoradores}

Los decoradores ofrecen una forma de modificar funciones utilizando otras funciones. Esto es ideal cuando se necesita extender la funcionalidad de funciones que no se quieren modificar.

\pythonfile{codigo/17-funcional/decorador_1.py}

En este caso, el uso la función envolver() se define dentro de decor() para permitir que decor() retorne una función, que es el objetivo principal de un decorador. La función texto\_decorado() es una versión decorada de la función imprimir\_texto().

De hecho, si se escribiera un decorador útil, podría reemplazarse imprimir\_texto() por su versión decorada.

\pythonfile{codigo/17-funcional/decorador_2.py}

En el ejemplo anterior, se decora la función print\_text() reemplazando la variable que contiene la función por una versión envuelta.

\pythonfile{codigo/17-funcional/decorador_3.py}

Este patrón puede utilizarse en cualquier momento, para envolver cualquier función.

Python ofrece apoyo para envolver una función en un decorador anteponiendo la definición de la función con el nombre de un decorador y el símbolo \@, lo cual tendrá el mismo resultado que el código de arriba.

\pythonfile{codigo/17-funcional/decorador_4.py}

Una sola función puede tener varios decoradores y cada decorador puede repetirse más de una vez.

\pythonfile{codigo/17-funcional/decorador_5.py}

Los decoradores pueden ser usados para muchos otros propósitos además de \doble{decorar}.

\pythonfile{codigo/17-funcional/decorador_entrada.py}

\pythonfile{codigo/17-funcional/decorador_tiempo.py}

\section{Recursión}

La recursión es un concepto muy importante en la programación funcional.

Lo fundamental de la recursión es la autorreferencia, funciones que se llaman a sí mismas. Se utiliza para resolver problemas que pueden ser divididos en subproblemas más sencillos del mismo tipo.

Un ejemplo clásico de una función que es implementada recursiva es la función factorial.

\pythonfile{codigo/17-funcional/factorial.py}

El caso base n == 0 actúa como condición de salida de la recursión, porque no involucra más llamadas a la función.

Las funciones recursivas pueden ser infinitas, al igual que los bucles while. Estas ocurren cuando se olvida implementar algún caso base.

Abajo se muestra una versión incorrecta de la función factorial. No tiene caso base, así que se ejecuta hasta que al interpretador se le acabe la memoria o se cuelgue.

\pythonfile{codigo/17-funcional/factorial_malo.py}

La recursión también puede ser indirecta. Una función puede llamar a una segunda, que a su vez llama a la primera, que llama a la segunda, y así sucesivamente. Esto puede ocurrir con cualquier cantidad de funciones.

\pythonfile{codigo/17-funcional/par_o_impar.py}

Otro ejemplo clásico es la serie de Fibonacci.

\pythonfile{codigo/17-funcional/fibonacci.py}

\section{Iteración vs. Recursión}

\clearpage\chapter{El módulo itertools}

\section{El módulo itertools}

El módulo itertools es una biblioteca estándar que contiene varias funciones que son útiles en la programación funcional.

\pythonfile{codigo/19-itertools/itertools.py}

\section{Iteradores infinitos}

Uno de los tipos de función que produce son iteradores infinitos.

La función count() cuenta infinitamente a partir de un valor.

\pythonfile{codigo/19-itertools/count_1.py}

Se le puede entregar un segundo parámetro a count(), el cual representa el tamaño de paso. Si no se le entrega el segundo parámetro, el tamaño de paso por defecto es 1.

\pythonfile{codigo/19-itertools/count_2.py}

Si el segundo parámetro es negativo, cuenta hacia atrás.

\pythonfile{codigo/19-itertools/count_3.py}

La función cycle() itera infinitamente a través de un iterable (como una lista o cadena).

\pythonfile{codigo/19-itertools/cycle_1.py}

\pythonfile{codigo/19-itertools/cycle_2.py}

La función repeat() repite un objeto, ya sea infinitamente o un número específico de veces.

\pythonfile{codigo/19-itertools/repeat_1.py}

Puede usarse para crear listas que tengan un objeto repetido.

\pythonfile{codigo/19-itertools/repeat_2.py}

Para repetir infinitamente, se le debe entregar sólo el objeto como parámetro.

\pythonfile{codigo/19-itertools/repeat_3.py}

\section{Operaciones sobre iterables}

Hay muchas funciones en itertools que operan sobre iterables, de una forma similar a map() o filter().

La función accumulate() devuelve un total actualizado de los valores dentro de un iterable.

\pythonfile{codigo/19-itertools/accumulate.py}

La función takewhile() toma elementos de un iterable mientras una función predicado permanece verdadera.

\pythonfile{codigo/19-itertools/takewhile_1.py}

La diferencia entre takewhile() y filter() es que takewhile() deja de tomar elementos cuando llega al primer elemento que no cumple la condición de la función.

\pythonfile{codigo/19-itertools/takewhile_2.py}

La función chain() combina varios iterables en uno solo más largo.

\pythonfile{codigo/19-itertools/chain.py}

\section{Funciones de combinatoria}

También hay numerosas funciones combinatorias en itertools, tales como product() y permutations(). Estas son usadas cuando se quiere cumplir tareas con todas las combinaciones posibles de algunos elementos.

La función product() retorna el producto entre 2 iterables.

\pythonfile{codigo/19-itertools/product.py}

La función permutations() retorna las todas permutaciones posibles entre los elementos de un iterable.

\pythonfile{codigo/19-itertools/permutations_1.py}

\pythonfile{codigo/19-itertools/permutations_2.py}

Se le puede entregar un segundo argumento, el cual representa el número de elementos que cada permutación debe tener.

\pythonfile{codigo/19-itertools/permutations_3.py}

El método combinations() funciona de forma similar a permutations(), pero muestra las combinaciones en vez de permutaciones.

\pythonfile{codigo/19-itertools/combinations.py}

La diferencia es que en las combinaciones no importa el orden y se unen todos los resultados que tienen los mismos elementos pero en orden distinto.

\clearpage\chapter{Programación orientada a objetos}

%TODO: mejorar la redacción en todo el capítulo

\section{Programación orientada a objetos}

Anteriormente se vieron 2 paradigmas de programación: imperativa (utilizando declaraciones, bucles y funciones como subrutinas) y funcional (utilizando funciones puras, funciones de orden superior y recursión).

Otro paradigma muy popular es la programación orientada a objetos (POO). Los objetos son creados utilizando clases, las cuales son en realidad el eje central de la POO.

\section{Clases}

La clase describe lo que el objeto será, pero es independiente del objeto mismo. En otras palabras, una clase puede ser descrita como los planos, la descripción o definición de un objeto. Una misma clase puede ser utilizada como plano para crear varios objetos diferentes.

Las clases son creadas utilizando la palabra clave class y un bloque indentado que contiene los métodos de una clase (los cuales son funciones).

\pythonfile{codigo/20-objetos/clases_1.py}

El código define una clase llamada Gato, la cual tiene el atributo color. Luego, la clase es utilizada para crear 2 objetos independientes de esa clase.

\section{Método \_\_init\_\_}

El método \_\_init\_\_ es el más importante de una clase. Es llamada cuando una instancia (objeto) de una clase es creada, utilizando el nombre de la clase como función.

Todos los métodos deben tener self como su primer parámetro. Aunque no sea pasado explícitamente, Python agrega el argumento self automáticamente. No se necesita entregar cuando se llaman los métodos.

Dentro de la definición de un método, self se refiere a la instancia que está llamando al método.

Las instancias de una clase tienen atributos, los cuales son datos asociados a ellas. En este ejemplo, las instancias de Gato tienen los atributos color y edad. Los atributos pueden ser accedidos al poner un punto seguido del nombre del atributo luego del nombre de una instancia.

\pythonfile{codigo/20-objetos/clases_2.py}

En un método \_\_init\_\_, self.atributo puede ser usado para fijar un valor inicial a los atributos de una instancia.

En el método mostrado anteriormente, el método \_\_init\_\_ recibe 2 argumentos y los asigna a los atributos del objeto. El método \_\_init\_\_ es llamado el constructor de la clase.

Si una clase no tiene atributos que se quieran inicializar con cada instancia, se puede omitir el método \_\_init\_\_.

\pythonfile{codigo/20-objetos/sin_constructor.py}

%TODO Separar esta sección

\section{Atributos}

\section{Métodos}

Las clases pueden tener otros métodos definidos para agregarles funcionalidad. Todos los métodos deben tener self como su primer parámetro.
Estos métodos son accedidos utilizando la misma sintaxis de punto que los atributos.

\pythonfile{codigo/20-objetos/clases_3.py}

\section{Atributos de clase}

Las clases pueden tener atributos de clase también, creados al asignar variables dentro del cuerpo de una clase. Estos pueden ser accedidos desde instancias de una clase o desde la clase misma.

\pythonfile{codigo/20-objetos/clases_4.py}

Los atributos de clase son compartidos por todas las instancias de una clase. Realizar algún cambio a un atributo de la clase también hará ese cambio en las instancias de esa clase.

\pythonfile{codigo/20-objetos/clases_5.py}

\section{Excepciones de clases}

Tratar de acceder a un atributo de una instancia que no está definida generará un AttributeError. Esto también aplica cuando se llama un método no definido.

\pythonfile{codigo/20-objetos/clases_6.py}

\section{Herencia}

La herencia brinda una manera de compartir funcionalidades entre clases.

Por ejemplo, las clases Perro, Gato, Conejo, etc. tienen algo en común. Aunque presenten algunas diferencias, también tienen muchas características en común. Este parecido puede ser expresado haciendo que todos hereden de una superclase Animal, que contiene las funcionalidades compartidas.

Para heredar de una clase desde otra, se coloca el nombre de la superclase entre paréntesis luego del nombre de la clase.

\pythonfile{codigo/20-objetos/herencia_1.py}

Una clase que hereda de otra clase se llama subclase. Una clase de la cual se hereda se llama superclase.

Si una clase hereda de otra con los mismos atributos o métodos, los sobreescribe.

\pythonfile{codigo/20-objetos/herencia_2.py}

La herencia también puede ser indirecta. Una clase hereda de otra, y esa clase puede a su vez heredar de una tercera clase.

\pythonfile{codigo/20-objetos/herencia_3.py}

Sin embargo, no es posible la herencia circular.

\section{Función super()}

La función super() es una útil función relacionada con la herencia que hace referencia a la clase padre. Puede ser utilizada para encontrar un método con un determinado nombre en la superclase del objeto.

\pythonfile{codigo/20-objetos/herencia_4.py}

También se puede usar para llamar al constructor de la superclase.

\pythonfile{codigo/20-objetos/herencia_5.py}

\section{Métodos mágicos}

Los métodos mágicos son métodos especiales que tienen doble guión bajo al principio y al final de sus nombres. Son también conocidos en inglés como dunders (de double underscores).

El constructor \_\_init\_\_ es un método mágico, pero existen muchos más. Son utilizados para crear funcionalidades que no pueden ser representadas en un método regular.

\section{Sobrecarga de operadores aritméticos}

Un uso común de métodos mágicos es la sobrecarga de operadores. Esto significa definir operadores para clases personalizadas que permiten que operadores tales como + y * sean utilizados en ellas.

El método mágico \_\_add\_\_ permite sobrecargar el operador +, lo cual permite darle un comportamiento personalizado.

\pythonfile{codigo/20-objetos/sobrecarga_operadores_1.py}

El método \_\_add\_\_ suma los atributos correspondientes de los objetos y devuelve un nuevo objeto que contiene el resultado. Una vez definido, se pueden sumar dos objetos de una clase entre sí.

Otra forma de verlo es que el intérprete de Python siempre interpretará el operador + como el método \_\_add\_\_ de su clase.

Los métodos mágicos para operadores comunes son:

\pythonfile{codigo/20-objetos/sobrecarga_operadores_2.py}

Y después el intérprete de Python interpreta los operadores así:

\pythonfile{codigo/20-objetos/sobrecarga_operadores_3.py}

A continuación, se muestra un ejemplo de implementación del método \_\_truediv\_\_.

\pythonfile{codigo/20-objetos/truediv.py}

La sobrecarga de operadores no necesita que los métodos mágicos nuevos cumplan su misma función original.
Un caso particular ocurre cuando \doble{x} e \doble{y} son de tipos distintos y \doble{x} no tiene definido un método mágico, por ejemplo \_\_add\_\_. En este caso, Python intentará calcular la operación al revés, la cual en este caso será y + x. Para realizar esta operación llamará al método reverso \_\_radd\_\_ de “y”.
Hay métodos r equivalentes para todos los operadores mencionados anteriormente.

\pythonfile{codigo/20-objetos/r_magicos.py}

Y un ejemplo de implementación de métodos reversos:

\pythonfile{codigo/20-objetos/radd.py}

\section{Sobrecarga de operadores de comparación}

Python también ofrece métodos mágicos para comparaciones.

\pythonfile{codigo/20-objetos/magicos_comparadores.py}

Si \_\_ne\_\_ no está implementado, devuelve el opuesto de \_\_eq\_\_. No hay ninguna otra relación entre los otros operadores.

\pythonfile{codigo/20-objetos/gt.py}

\section{Métodos mágicos de contenedores}

Hay varios métodos mágicos para hacer que las clases actúen como contenedores.

\pythonfile{codigo/20-objetos/magicos_contenedores.py}

A continuación, se muestra un ejemplo rebuscado pero creativo, el cual consiste en crear una clase de lista poco confiable o imprecisa.

\pythonfile{codigo/20-objetos/lista_imprecisa.py}

%TODO: Investigar más métodos mágicos

\section{Ciclo de vida de un objeto}

El ciclo de vida de un objeto está conformado por su creación, manipulación y destrucción.

La primera etapa del ciclo de vida de un objeto es la definición de la clase a la cual pertenece.

La siguiente etapa es la instanciación de un objeto, cuando el método \_\_init\_\_ es llamado. La memoria es asignada para almacenar la instancia. Justo antes de que esto ocurra, el método \_\_new\_\_ de la clase es llamado, para asignar la memoria necesaria. Este es normalmente redefinido sólo en casos especiales.

Luego de que ocurra lo anterior el objeto estará listo para ser utilizado.

Otro código puede interactuar con el objeto, llamando sus métodos o accediendo a sus atributos. Eventualmente, terminará de ser utilizado y podrá ser destruido.

Cuando un objeto es destruido, la memoria asignada se libera y puede ser utilizada para otros propósitos.

La destrucción de un objeto ocurre cuando su contador de referencias llega a cero. La cuenta de referencias es el número de variables y otros elementos que se refieren al objeto.

Si nada se está refiriendo al objeto (tiene una cuenta de referencias de 0) nada puede interactuar con este, así que puede ser eliminado con seguridad.
En algunas situaciones, dos (o más) objetos pueden solo referirse entre ellos, y por lo tanto pueden ser eliminados también.

La sentencia del reduce la cuenta de referencias de un objeto por 1, y a menudo conlleva a su eliminación. El método mágico de la sentencia del es \_\_del\_\_.

El proceso de eliminación de objetos cuando ya no son necesarios se denomina recolección de basura (garbage collection).

En resumen, el contador de referencias de un objeto se incrementa cuando se le es asignado un nuevo nombre o es colocado en un contenedor (una lista, tupla o diccionario). La cuenta de referencias de un objeto se disminuye cuando es eliminado con del, su referencia es reasignada, o su referencia sale fuera del alcance. Cuando la cuenta de referencias de un objeto llega a 0, Python lo elimina automáticamente.

\pythonfile{codigo/20-objetos/contador_referencias.py}

Lenguajes de bajo nivel como C no tienen esta clase de manejo de memoria automático.

\section{Ocultamiento de información}

Un componente clave de la programación orientada a objetos es el encapsulamiento, que involucra empaquetar las variables y funciones relacionadas en un único objeto fácil de usar, una instancia de una clase.

Un concepto asociado es el de ocultamiento de información, el cual dicta que los detalles de implementación de una clase deben estar ocultos y que sean presentados a aquellos que quieran utilizar la clase en una interfaz estándar limpia. En otros lenguajes de programación, esto se logra normalmente utilizando métodos y atributos privados, los cuales bloquean el acceso externo a ciertos métodos y atributos en una clase.

La filosofía de Python es ligeramente diferente. A menudo se dice \doble{todos somos adultos consistentes aquí}, que significa que no deberías poner restricciones arbitrarias al acceso de las partes de una clase. Por ende, no hay formas de imponer que un método o atributo sea estrictamente privado.

Sin embargo, hay maneras de desalentar a la gente de acceder a las partes de una clase, tales como denotar que es un detalle de implementación y debe ser utilizado a su cuenta y riesgo.

Los métodos y atributos débilmente privados tienen un único guión bajo al principio. Esto señala que son privados, y no deberían ser utilizados por código externo.

Sin embargo, es en su mayor parte sólo una convención, y no impide que el código externo los acceda. Su único efecto verdadero es que \mintinline{python}{from nombre_de_modulo import *} no importará a las variables que empiecen por un único guión bajo.

\section{Métodos de clase}

\section{Métodos estáticos}

\section{Propiedades}

\clearpage\chapter{Expresiones regulares}

\section{Expresiones regulares}

\clearpage\chapter{Empaquetamiento}

\clearpage\chapter{Interfaz gráfica}

\clearpage\chapter{Algoritmos de ordenamiento}

\clearpage\chapter{Algoritmos de búsqueda}

\clearpage\chapter{Algoritmos de matrices}

\clearpage\chapter{Implementación de estructuras de datos}

\clearpage\chapter{La librería NumPy}

\end{document}