\documentclass{report}

\usepackage[utf8]{inputenc}

\usepackage[a4paper, left=3cm, right=3cm, top=2.5cm, bottom=2.5cm]{geometry}

\usepackage[outputdir=build]{minted}
\usepackage{sectsty}
\usepackage{tocloft}

\usepackage{enumitem}

\usepackage{graphicx}
\usepackage[svgnames]{xcolor}

\usepackage{amsmath}

%\usepackage{inconsolata}
\usepackage[scaled]{beramono}
\usepackage[T1]{fontenc}

\usepackage{textcomp}
\usepackage{upquote}

\usepackage[spanish]{babel}
\usepackage[colorlinks=true, linkcolor=., urlcolor=ForestGreen]{hyperref}

% estilo de los segmentos de código
\usemintedstyle[python]{material}

% colores de capítulos y secciones
\chapterfont{\color{black}}
\sectionfont{\color{DarkBlue}}

% también en la tabla de contenidos
\renewcommand{\cftchapfont}{\bfseries\color{black}}
\renewcommand{\cftsecfont}{\color{black}}

% párrafos sin sangría
\setlength\parindent{0pt}

% cambiar espacio entre números y texto en la tabla de contenidos
\setlength\cftchapnumwidth{2em}
\setlength\cftsecnumwidth{3em}

% quitar sangría de itemize y enumerate
\setlist[itemize]{leftmargin=*}
\setlist[enumerate]{leftmargin=*}

% comandos nuevos para comillas simples y dobles
\newcommand{\simple}[1]{`#1'}
\newcommand{\doble}[1]{``#1''}

\newcommand{\link}[2]{\href{#1}{\underline{#2}}}

\definecolor{grisoscuro}{RGB}{32, 32, 32}
\definecolor{grisclaro}{RGB}{223, 223, 223}

% macros nuevas para minted
\newmintedfile[pythonfile]{python}{
  bgcolor=grisoscuro,
  breaklines,
  samepage=true
}
\newmintedfile[outfile]{text}{
  bgcolor=grisclaro,
  frame=single,
  breaklines,
  samepage=true,
  breakafter=0  % para un caso específico
}
\newmintedfile[textfile]{text}{
  bgcolor=white,
  frame=single,
  breaklines,
  samepage=true
}
\newmintedfile[pythonspaces]{python}{
  bgcolor=grisoscuro,
  breaklines,
  showspaces,
  spacecolor=white,
  tabsize=4,
  obeytabs,
  showtabs,
  tabcolor=white,
  tab=\rightarrowfill,
  samepage=true
}

% para escribir "Salida:" siempre que se muestre el output
\newcommand{\out}[1]{Salida:\outfile{#1}}
% lo mismo pero para entrada
\newcommand{\inp}[1]{Entrada:\outfile{#1}}
% para archivo original
\newcommand{\Ainicial}[1]{Archivo inicial:\textfile{#1}}
% para archivo resultante
\newcommand{\Afinal}[1]{Archivo final:\textfile{#1}}

% se usan en tablas
\newcommand{\si}{\textcolor{ForestGreen}{Sí}}
\newcommand{\no}{\textcolor{Crimson}{No}}
\newcommand{\noo}{\textcolor{Crimson}{No*}}
\newcommand{\inicio}{\textcolor{DodgerBlue}{Inicio}}
\newcommand{\final}{\textcolor{RoyalBlue}{Final}}
\newcommand{\indices}{\textcolor{ForestGreen}{Índices}}
\newcommand{\claves}{\textcolor{ForestGreen}{Claves}}

% atajo para usar \texttt{} más rápido, ya que se usará muy seguido
\newcommand{\ttt}[1]{\textcolor{Crimson}{\texttt{#1}}}

% para usar comillas de tipo "programación"
\newcommand{\q}{\textquotesingle}
\newcommand{\qq}{\textquotedbl}

% para insertar una linea horizontal, todavía no se usa
\newcommand{\hr}{\noindent\hrulefill}

\title{Resumen Python 3}
\author{Víctor Mardones Bravo}
\date{Febrero de 2021}

\begin{document}

% la primera hoja no tiene números de página
\pagenumbering{gobble}

% brujería para centrar el título y logo
\null
\nointerlineskip
\vfill
\let\snewpage \newpage
\let\newpage \relax
% se centra el logo svg exportado con Inkscape
  {\centering\def\svgwidth{\columnwidth}
  \input{logo\\python-logo-inkscape.pdf_tex}}
\maketitle
\let \newpage \snewpage
\vfill 
\break

\clearpage

% tabla de contenido
\tableofcontents

\clearpage

% el resto del documento tiene números de página
\pagenumbering{arabic}

\chapter{Introducción a Python}

\section{¿Qué es Python?}

\link{https://www.python.org}{Python} es un lenguaje de programación de alto nivel, con aplicaciones en numerosas áreas, incluyendo automatización de tareas, programación web, scripting, manejo de grandes cantidades de datos, computación científica, cálculos complejos e inteligencia artificial.\smallskip

Fue diseñado por Gudo van Rossum. Fue lanzado en el año 1991. Se han lanzado diferentes versiones hasta llegar a la versión actual, Python 3.

\section{Componentes principales}

\begin{itemize}
  \item Funciones: Python tiene funciones predefinidas que son de gran utilidad, por ejemplo las funciones matemáticas. Las funciones son grupos de bloques de código que pueden ejecutarse en cualquier sección del código, según el programador lo necesite.
  
  \item Clases: Son los planos para construir objetos, los cuales incluyen todas sus características y comportamientos. En Python, prácticamente todo es un objeto, aunque en muchos casos no parezca obvio.
  
  \item Módulos: Agrupan funciones y clases que sirven para objetivos similares. La biblioteca estándar de Python es muy grande comparada con las de otros lenguajes de programación.
  
  \item Paquetes: Agrupan módulos usados en aplicaciones grandes, permitiendo su distribución a terceros.
  
\end{itemize}

Si estos conceptos no se entienden todavía, no hay problema, pues se verán más a fondo en sus respectivos capítulos.

\section{Características de Python}

\begin{itemize}
  \item Soporte de múltiples plataformas: Python es \doble{platform independent}. Esto significa que un mismo código puede ejecutarse en cualquier sistema operativo, ya sea Windows, Unix, Linux o Mac, sin necesidad de hacerle cambios.
  
  \item Interpretado: El código escrito en Python no necesita ser compilado, como ocurre en lenguajes como C, Java o C++. El intérprete de Python convierte el código en bytes ejecutables línea por línea, lo cual hace su utilización más conveniente para el programador, pero al mismo tiempo más lenta.
  
  \item Simple: La sintaxis de Python es simple y fácil de leer, aunque requiere un conocimiento de inglés básico.
  
  \item Robusto: Esto significa que el lenguaje es capaz de manejar los posibles errores que podrían ocurrir durante la ejecución de programas escritos en él.
  
  \item De alto nivel: Es un lenguaje de nivel usado para scripting. Esto quiere decir que el programador no necesita recordar características de bajo nivel como la arquitectura del sistema o el manejo de memoria. Estas características se abstraen.
  
  \item Gran soporte de librerías: Python puede integrarse a otras librerías que tengan funcionalidades específicas. No hay necesidad de tener que escribir el código por tu cuenta, si ya existe y funciona correctamente.
  
  \item Integrable: El código fuente escrito en Python puede usarse dentro de otros lenguajes de programación, lo cual permite expandir las funcionalidades de sus programas con las de programas escritos en otros lenguajes.
  
  \item De código abierto: Python es de \link{https://opensource.org/about}{código abierto}. Se puede usar sin necesidad de tomar su licencias y se puede descargar fácilmente.
  
  \item Gratuito: Ninguna persona u organización necesita pagar para usarlo en sus proyectos.
  
  \item Conciso y compacto: El código escrito en Python es conciso y compacto, lo que sirve para que los programadores puedan entenderlo rápidamente.
  
  \item Dinámicamente tipeado: El tipo de dato de cada variable se decide durante el tiempo de ejecución, lo que significa que no es necesario declarar su tipo en el código.
  
\end{itemize}

\section{Organizaciones que lo usan}

Python es muy popular y es usado por organizaciones y aplicaciones como:

\begin{itemize}
  \item \link{https://www.microsoft.com/en-us/}{Microsoft}

  \item \link{https://www.google.com}{Google}
  
  \item \link{https://www.yahoo.com}{Yahoo}
  
  \item \link{https://www.mozilla.org/en-US/}{Mozilla}
  
  \item \link{https://www.cisco.com}{Cisco}
  
  \item \link{https://www.facebook.com}{Facebook}
  
  \item \link{https://www.spotify.com}{Spotify}
  
  \item \link{https://www.openstack.org}{OpenStack}

  \item \link{https://www.nasa.gov}{NASA}
  
  \item \link{https://www.cia.gov}{CIA}
  
  \item \link{https://www.disney.com}{Disney}
  
\end{itemize}

\section{Ventajas y desventajas}

Ventajas:

\begin{itemize}
  \item Es de código abierto y fácil de empezar a usar.
  
  \item Es fácil de aprender y explorar.
  
  \item Se pueden integrar módulos de terceros con facilidad.
  
  \item Es un lenguaje de alto nivel y orientado a objetos.
  
  \item Es interactivo y portable.
  
  \item Las aplicaciones pueden ejecutarse en cualquier plataforma.
  
  \item Es dinámicamente tipeado.
  
  \item Tiene una comunidad grande y foros activos.
  
  \item Tiene una sintaxis intuitiva.
  
  \item Tiene librerías con amplio soporte.
  
  \item Es un lenguaje interpretado.
  
  \item Se puede conectar con bases de datos.
  
  \item Aumenta la productividad debido a su simplicidad.
  
\end{itemize}

Desventajas:

\begin{itemize}
  \item No puede usarse para desarrollo de aplicaciones móviles.
  
  \item Su acceso a bases de datos es limitado.
  
  \item Consume más memoria por ser dinámicamente tipeado.
  
  \item Su ejecución es lenta comparada con lenguajes compilados.
  
  \item Las aplicaciones y código requieren mayor mantenimiento, debido a su gran grado de abstracción.

  \item Debido a su abstracción, algunos conceptos de programación importantes podrían ser omitidos durante su aprendizaje.

\end{itemize}

No hay limitaciones en lo que se puede construir usando Python. Esto incluye aplicaciones autónomas, aplicaciones web, juegos, ciencia de datos, modelos de machine learning y mucho más.\smallskip

Dato curioso: Según el creador Guido van Rossum, el nombre de Python viene de la serie de comedia británica \doble{El Circo Volador de Monty Python}.

\section{Instalación}

%TODO: instalación

\section{Hola mundo}

Para mostrar el texto \doble{Hola mundo} en pantalla se puede usar la función \ttt{print()}.

\pythonfile{codigo/1-intro/hola_mundo_1.py}
\out{codigo/1-intro/hola_mundo_1.out}

Cada declaración de impresión \ttt{print()} genera texto en una nueva línea.

\pythonfile{codigo/1-intro/hola_mundo_2.py}
\out{codigo/1-intro/hola_mundo_2.out}

Si no se le entrega ningún texto a \ttt{print()}, se imprimirá una línea vacía. El texto puede escribirse entre comillas simples o dobles.

\pythonfile{codigo/1-intro/hola_mundo_3.py}
\out{codigo/1-intro/hola_mundo_3.out}

\section{El Zen de Python}

El \link{https://www.python.org/dev/peps/pep-0020/}{Zen de Python} es una colección de 20 \doble{principios}, 19 de ellos escritos por Tim Peters. Estos principios han servido como inspiración para muchos programadores de todo el mundo a la hora de crear software.\smallskip

Se mostrará en pantalla como un \doble{huevo de pascua} la primera vez que se ejecute la siguiente linea, para importar el módulo \ttt{this}.

\pythonfile{codigo/1-intro/import_this.py}

Después se mostrará el siguiente texto, en inglés.

\textfile{codigo/1-intro/zen.txt}

Una traducción posible sería la siguiente:

\textfile{codigo/1-intro/zen_spanish.txt}

Nota: Si se observa con claridad, se puede ver que el principio 20 \doble{no existe}.
%TODO: explicar qué ocurrió

\clearpage\chapter{Conceptos básicos}

\section{Comentarios}

Los comentarios son anotaciones en el código utilizadas para hacerlo más fácil de entender. No afectan la ejecución del código.\smallskip

En Python, los comentarios comienzan con el símbolo \ttt{\#}. Todo el texto luego de este \ttt{\#} (dentro de la misma línea) es ignorado.

\pythonfile{codigo/2-basico/comentario_1.py}

La mayoría de editores de código marcan los comentarios con su propio color, distinto al del resto de código.

\pythonfile{codigo/2-basico/comentario_2.py}
\out{codigo/2-basico/comentario_2.out}

Python no tiene comentarios multilínea para fines generales como lo tienen otros lenguajes de programación tales como C. Para comentar varias líneas de código se debe antener un comentario a cada línea.

\pythonfile{codigo/2-basico/comentario_multilinea.py}

Por último, se debe recordar no abusar del uso de comentarios. No es conveniente llenar el código de comentarios o comentar cosas que son demasiado obvias.

\pythonfile{codigo/2-basico/comentario_innecesario.py}

\section{Números enteros}

Los números enteros (integer) son el tipo de dato más básico en muchos lenguajes de programación, y Python no es la excepción.\smallskip

Para mostrar un número en pantalla, sólo basta con usar la función \ttt{print()} y entregarle el número. El número debe escribirse sin usar comillas y Python inferirá su tipo automáticamente.

\pythonfile{codigo/2-basico/numero_1.py}
\out{codigo/2-basico/numero_1.out}

A diferencia de otros lenguajes de programación, los números en Python 3 son de largo arbitrario, en otras palabras, soportan \link{https://stackoverflow.com/questions/13795758/what-is-sys-maxint-in-python-3}{cualquier cantidad de dígitos}. Esto hace que los cálculos con números grandes sean mucho más convenientes, pero reduce el rendimiento.

\pythonfile{codigo/2-basico/numero_2.py}
\out{codigo/2-basico/numero_2.out}

\section{Operaciones aritméticas}

Python tiene la capacidad de realizar cálculos. Los operadores \ttt{+}, \ttt{-}, \ttt{*} y \ttt{/} representan suma, resta, multiplicación y división, respectivamente.

\pythonfile{codigo/2-basico/aritmetica_1.py}
\out{codigo/2-basico/aritmetica_1.out}

Los espacios entre los signos y los números son opcionales, pero hacen que el código sea más fácil de leer.\smallskip

El resultado de una división es un número decimal. Esto lo convierte al tipo de dato float, el cual se verá más tarde en este capítulo.

\pythonfile{codigo/2-basico/division.py}
\out{codigo/2-basico/division.out}

Todas las operaciones se pueden combinar entre sí como si el intérprete de Python fuera una calculadora.

\pythonfile{codigo/2-basico/calculadora.py}
\out{codigo/2-basico/calculadora.out}

\section{La regla PEMDAS}

Las operaciones en Python siguen el orden dado por la regla PEMDAS:

\begin{enumerate}
  \item Paréntesis \ttt{()}
  
  \item Exponentes \ttt{**}
  
  \item Multiplicación \ttt{*} y división \ttt{/} (de izquierda a derecha)
  
  \item Adición \ttt{+} y Sustracción \ttt{-} (de izquierda a derecha)
  
\end{enumerate}

A continuación se muestra un ejemplo detallando el orden en el que se procesan las operaciones.

\pythonfile{codigo/2-basico/aritmetica_2.py}
\out{codigo/2-basico/aritmetica_2.out}

En realidad, la regla PEMDAS es parte de una jerarquía de operadores mucho más grande, que incluye todos los operadores que se pueden usar en Pyhon. Esta jerarquía se verá más tarde.

\section{Paréntesis}

Se pueden usar paréntesis \ttt{()} para agrupar operaciones y hacer que estas se realicen primero, siguiendo la regla PEMDAS.

\pythonfile{codigo/2-basico/aritmetica_3.py}
\out{codigo/2-basico/aritmetica_3.out}

\section{Floats}
    
Para representar números racionales o que no son enteros, se usa el tipo de dato float o punto flotante. Se pueden crear directamente ingresando un número con un punto decimal, o como resultado de una división.

\pythonfile{codigo/2-basico/float_1.py}
\out{codigo/2-basico/float_1.out}

Se debe tener en cuenta que los computadores \link{http://puntoflotante.org/formats/fp/}{no pueden almacenar perfectamente} el valor de los floats, lo cual a menudo conduce a errores.

\pythonfile{codigo/2-basico/error_float.py}
\out{codigo/2-basico/error_float.out}

El error mostrado arriba es un error clásico de la aritmética de punto flotante. Es un error tan conocido que incluso tiene su propio \link{https://0.30000000000000004.com}{sitio web}.\smallskip

Al trabajar con floats, no es necesario escribir un 0 a la izquierda del punto decimal.

\pythonfile{codigo/2-basico/float_2.py}
\out{codigo/2-basico/float_2.out}

Esta notación se asemeja a decir \doble{punto cinco} en vez de \doble{cero punto cinco}.\smallskip

El resultado de cualquier operación entre floats o entre un float y un entero siempre dará como resultado un float. La división entre enteros también da como resultado un float.

\pythonfile{codigo/2-basico/float_3.py}
\out{codigo/2-basico/float_3.out}

Las operaciones entre floats y enteros son posibles porque Python convierte los enteros en floats silenciosamente al momento de realizarlas.

\section{Exponenciación}

Otra operación soportada es la exponenciación, que es la elevación de un número a la potencia de otro. Esto se realiza usando el operador \ttt{**}.\smallskip

Ejemplo equivalente a $2 ^ 5 = 2\cdot 2\cdot 2\cdot 2\cdot 2 = 32$.

\pythonfile{codigo/2-basico/potencia.py}
\out{codigo/2-basico/potencia.out}

Las exponenciaciones se pueden encadenar cuantas veces se desee.\smallskip

%TODO: enlace a googol
Ejemplos equivalentes a ${2 ^ 3} ^ 2 = 512$ y $10 ^ {100}$ (un googol).

\pythonfile{codigo/2-basico/potencia_multiple.py}
\out{codigo/2-basico/potencia_multiple.out}

Se debe tener cuidado con los paréntesis al encadenar potencias.\smallskip

Ejemplos equivalentes a ${2 ^ 3} ^ 2 = 512$ y $(2 ^ 3) ^ 2 = 64$.

\pythonfile{codigo/2-basico/potencia_cuidado.py}
\out{codigo/2-basico/potencia_cuidado.out}

La exponenciación también se puede hacer con floats, donde se puede usar para obtener raíces. El resultado será un float.\smallskip

Ejemplos equivalentes a $\sqrt{9} = 3$ y $\sqrt[3]{8} = 2$.

\pythonfile{codigo/2-basico/raiz.py}
\out{codigo/2-basico/raiz.out}

Se debe tener en cuenta que el resultado será un float.

\section{Cociente y resto}

%TODO: investigar que sucede con números negativos

La división entera se realiza usando el operador \ttt{//}, donde el resultado es la parte entera que queda al realizar la división, también conocida como cociente.\smallskip

La división entera retorna un entero en vez de un float.

\pythonfile{codigo/2-basico/cociente.py}
\out{codigo/2-basico/cociente.out}

También se puede usar la división entera con floats, lo cual dará como resultado otro float.

\pythonfile{codigo/2-basico/cociente_floats.py}
\out{codigo/2-basico/cociente_floats.out}

Para obtener el resto al realizar una división entera, se debe usar el operador módulo \ttt{\%}.

\pythonfile{codigo/2-basico/resto.py}
\out{codigo/2-basico/resto.out}

Esta operación es equivalente a $7 \mod{2}$ en aritmética modular.\smallskip

Este operador viene de la \link{https://es.khanacademy.org/computing/computer-science/cryptography/modarithmetic/a/what-is-modular-arithmetic}{aritmética modular}, y uno de sus usos más comunes es para saber si un número es múltiplo de otro. Esto se hace revisando si el módulo al dividirlo por ese otro número es 0.

\pythonfile{codigo/2-basico/uso_del_resto.py}
\out{codigo/2-basico/uso_del_resto.out}

En el caso mostrado anteriormente, se infiere que 10 es múltiplo de 2, que 15 es múltiplo de 3 y que 16 no es múltiplo de 7. El caso particular módulo 2 también puede usarse para saber si un número es par o no.\smallskip

El operador módulo \ttt{\%} también puede usarse con floats.

\pythonfile{codigo/2-basico/resto_floats.py}
\out{codigo/2-basico/resto_floats.out}

\clearpage\chapter{Cadenas de texto}

\section{Strings o cadenas de caracteres}

Las cadenas de caracteres se crean introduciendo el texto entre comillas simples \ttt{\q \q} o dobles \ttt{\qq \qq}.

\pythonfile{codigo/3-strings/string.py}
\out{codigo/3-strings/string.out}

El uso de comillas simples o dobles no afecta en ninguna forma el comportamiento del string, es decir, ambos producen el mismo resultado.\smallskip

Un string debe empezar y terminar con comillas del mismo tipo, no se permiten comillas mixtas.

\pythonfile{codigo/3-strings/string_no_valido_1.py}
\out{codigo/3-strings/string_no_valido_1.out}

\pythonfile{codigo/3-strings/string_no_valido_2.py}
\out{codigo/3-strings/string_no_valido_2.out}

\section{Cadena vacía}

A veces es necesario inicializa un string, pero sin agregarle información. Una cadena vacía es definida como \ttt{\q \q} o \ttt{\qq \qq}.

\pythonfile{codigo/3-strings/cadena_vacia.py}

Estos strings vacíos se inicializan en variables, lo cual se verá en el capítulo siguiente.

\section{Caracteres especiales}

Algunos caracteres no se pueden incluir directamente en una cadena. Para esos casos, se debe incluir la barra diagonal inversa \ttt{\textbackslash} antes de ellos.

\pythonfile{codigo/3-strings/caracteres_especiales.py}
\out{codigo/3-strings/caracteres_especiales.out}

Los caracteres \ttt{\q}, \ttt{\qq} y \ttt{\textbackslash} son especiales, porque normalmente cumplen funciones especiales dentro de strings.\smallskip

Si el string se define entre comillas dobles, no es necesario poner \ttt{\q} para ingresar comillas simples dentro de él, y viceversa.

\pythonfile{codigo/3-strings/comillas.py}
\out{codigo/3-strings/comillas.out}

\section{Secuencias de escape}

Las secuencias de escape también se pueden incluir usando el símbolo \ttt{\textbackslash} dentro de cadenas de texto. Su origen viene de las secuencias de escape usadas en las máquinas de escribir.\smallskip

Las secuencias de escape más usadas son:

\begin{itemize}
  \item Nueva línea (new line): Avanza una línea hacia adelante (salto de línea) y deja el cursor al principio de esta línea (retorno de carro). Representado por \ttt{\textbackslash n}.
  
  \pythonfile{codigo/3-strings/newline.py}
  \out{codigo/3-strings/newline.out}
  
  Cualquier caracter después de \ttt{\textbackslash n} queda en la línea siguiente.

  \item Tabulador horizontal (horizontal tab): Añade un salto de tabulador horizontal. Representado por \ttt{\textbackslash t}.
  
  \pythonfile{codigo/3-strings/tab.py}
  \out{codigo/3-strings/tab.out}
  
  El salto de tabulador avanza hasta el siguiente \doble{tab stop} de la misma línea.

\end{itemize}

Otras secuencias de escape que no son tan usadas son:

\begin{itemize}
  \item Retorno de carro (carriage return): Mueve el \doble{carro} (cursor) al principio de la línea actual. Esto permite sobreescribir los caracteres escritos anteriormente. Representado por \ttt{\textbackslash r}.
  
  \pythonfile{codigo/3-strings/carriage_return.py}
  \out{codigo/3-strings/carriage_return.out}

  En algunos intérpretes, borra la línea además de volver al inicio.

  \item Retroceso (backspace): Borra el último carácter y mueve el cursor al carácter anterior. Representado por \ttt{\textbackslash b}.
  
  \pythonfile{codigo/3-strings/backspace.py}
  \out{codigo/3-strings/backspace.out}

  \item Tabulador vertical (vertical tab): Añade un salto de tabulador vertical. Representado por \ttt{\textbackslash v}.
  
  \pythonfile{codigo/3-strings/vtab.py}

  La tabulación vertical avanza hasta la siguiente línea que sea una \doble{tab stop}.

  \item Salto de página (form feed): Baja a la próxima \doble{página}. Representado por \ttt{\textbackslash f}.
  
  \pythonfile{codigo/3-strings/form_feed.py}
  
  Algunos programadores los usaban para separar distintas secciones de código en \doble{páginas}.

\end{itemize}

El resultado obtenido de estas últimas puede variar dependiendo del IDE que se utilice.

\section{Caracteres Unicode}

Las barras diagonales inversas también se pueden usar para escribir caracteres Unicode arbitrarios. Se escriben como \ttt{\textbackslash u} seguido del código del carácter Unicode (en hexadecimal).\smallskip

Los códigos Unicode se aceptan sin importar que tengan mayúsculas o minúsculas.

\pythonfile{codigo/3-strings/unicode.py}
\out{codigo/3-strings/unicode.out}

El \link{https://unicode.org/}{sitio web de Unicode} contiene más información sobre estos caracteres y sobre este estándar. \link{https://unicode-table.com/en/}{Este sitio web} tiene una tabla con los códigos.

\section{Strings multilínea}

Este es un tipo especial de string, que se escribe entre comillas triples \ttt{\q\q\q \q\q\q} o \ttt{\qq\qq\qq \qq\qq\qq}, y que reconoce los saltos de línea sin necesidad de usar la secuencia \ttt{\textbackslash n}.

\pythonfile{codigo/3-strings/string_multilinea.py}
\out{codigo/3-strings/string_multilinea.out}

\section{Concatenación de strings}

Se pueden realizar operaciones matemáticas no solo con números, sino también con cadenas.\smallskip

Dos o más cadenas se pueden unir una después de la otra, usando un proceso llamado concatenación. Se usa el operador \ttt{+}.

\pythonfile{codigo/3-strings/concatenacion.py}
\out{codigo/3-strings/concatenacion.out}

La concatenación sólo se puede realizar entre strings, no entre cadenas y números.

\pythonfile{codigo/3-strings/error_concatenacion.py}
\out{codigo/3-strings/error_concatenacion.out}

\section{Multiplicación de strings}

Las cadenas también pueden ser multiplicadas por números enteros. Esto produce una versión repetida de la cadena original. El orden de la cadena y el número no importa, pero la cadena suele ir primero.

\pythonfile{codigo/3-strings/multiplicar_cadenas_1.py}
\out{codigo/3-strings/multiplicar_cadenas_1.out}

También se pueden combinar operaciones de multiplicación y concatenación.

\pythonfile{codigo/3-strings/concatenacion_y_multiplicacion.py}

Multiplicar por \ttt{0} genera un string vacío.

\pythonfile{codigo/3-strings/multiplicar_cadenas_2.py}
\out{codigo/3-strings/multiplicar_cadenas_2.out}

Las cadenas no pueden ser multiplicadas entre sí, tampoco pueden ser multiplicadas por floats, incluso si los floats son números enteros.

\pythonfile{codigo/3-strings/cadena_x_cadena.py}
\out{codigo/3-strings/cadena_x_cadena.out}

\pythonfile{codigo/3-strings/cadena_x_float.py}
\out{codigo/3-strings/cadena_x_float.out}

\section{Opciones del método print()}

El método \ttt{print()} puede aceptar más de un string como argumento, lo cual hace que se muestren en una misma línea separados por espacios.

\pythonfile{codigo/3-strings/print_avanzado_1.py}
\out{codigo/3-strings/print_avanzado_1.out}

El método \ttt{print()} tiene 2 argumentos que pueden definirse para dar más control sobre lo que se imprime en la pantalla.\smallskip

El argumento \ttt{sep} define el string separador entre cada string \doble{normal} que se le entregue al método \ttt{print()}, excepto después del último. Estos separadores pueden incluir secuencias de escape.

\pythonfile{codigo/3-strings/print_avanzado_2.py}
\out{codigo/3-strings/print_avanzado_2.out}

El argumento \ttt{end} define el string que irá después del último string \doble{normal}. Se puede usar para seguir escribiendo en la misma línea, si no se incluye la secuencia de escape \ttt{\textbackslash n}.

\pythonfile{codigo/3-strings/print_avanzado_3.py}
\out{codigo/3-strings/print_avanzado_3.out}

\pythonfile{codigo/3-strings/print_avanzado_4.py}
\out{codigo/3-strings/print_avanzado_4.out}

Ambos argumentos se pueden combinar.

\pythonfile{codigo/3-strings/print_avanzado_5.py}
\out{codigo/3-strings/print_avanzado_5.out}

\section{Párrafos}

Una secuencia de escape útil para escribir párrafos o cualquier texto largo en general, que no tenga saltos de línea en su interior, es usando la sucuencia de escape \ttt{\textbackslash} seguida de un salto de línea (en el código).\smallskip

Esto permite escribir strings largos que no pueden verse completamente en pantalla sin tener que moverse hacia la derecha. El uso de esta secuencia de escape no altera el resultado.

\pythonfile{codigo/3-strings/lorem_ipsum.py}
\out{codigo/3-strings/lorem_ipsum.out}

%TODO: referencia y enlace a lorem ipsum

\clearpage\chapter{Variables}

\section{Asignación de variables}

Una variable permite almacenar un valor asignándole un nombre, el cual puede ser usado para referirse al valor más adelante en el programa. Para asignar una variable, se usa el signo de igualdad \ttt{=}.

\pythonfile{codigo/4-variables/variable_1.py}
\out{codigo/4-variables/variable_1.py}

En Python, no existe la declaración de variables. Toda variable que se cree debe tener un valor inicial asignado. Se permite que este valor pueda ser \doble{vacío}, como por ejemplo el string vacío \ttt{\qq \qq}.

\section{Nombre de variables válidos}

Se aplican ciertas restricciones con respecto a los caracteres que se pueden usar en los nombres de variables. Los únicos caracteres permitidos son letras, números y guiones bajos \ttt{\_}. Además, no se puede comenzar con números o incluir espacios.\smallskip

No seguir estas reglas hará que ocurran errores que impiden la ejecución del programa.

\pythonfile{codigo/4-variables/error_variable_1.py}
\out{codigo/4-variables/error_variable_1.out}

\pythonfile{codigo/4-variables/error_variable_2.py}
\out{codigo/4-variables/error_variable_2.out}

\pythonfile{codigo/4-variables/error_variable_3.py}
\out{codigo/4-variables/error_variable_3.out}

Python es sensible a mayúsculas y minúsculas, lo que significa que las variables \ttt{num}, \ttt{Num}, \ttt{NUM}, etc. son distintas.

\pythonfile{codigo/4-variables/mayusculas_y_minusculas.py}
\out{codigo/4-variables/mayusculas_y_minusculas.out}

\section{Palabras clave}

Existen palabras específicas que tampoco se pueden usar como nombres de variables. El intérprete de Python reconoce estas palabras como palabras clave o keywords, y tienen usos reservados.\smallskip

A continuación, se muestra una lista de todas las palabras clave en Python.

\textfile{codigo/4-variables/palabras_clave.txt}

Nótese el uso de mayúsculas al principio de \ttt{False}, \ttt{None} y \ttt{True}.

\section{Operaciones con variables}

Se pueden usar variables dentro de operaciones.

\pythonfile{codigo/4-variables/variable_2.py}
\out{codigo/4-variables/variable_2.out}

Pero se debe recordar que deben ser asignadas antes de poder usarlas.

\pythonfile{codigo/4-variables/error_operacion.py}
\out{codigo/4-variables/error_operacion.out}

Una variable también puede cambiar de valor a lo largo de la ejecución de un programa, y ser el resultado de operaciones con otras variables.

\pythonfile{codigo/4-variables/variable_3.py}

Durante el tiempo de ejecución, siempre mantendrá el último valor que se le asignó.

\pythonfile{codigo/4-variables/conservacion.py}
\out{codigo/4-variables/conservacion.out}

Las variables se pueden reasignar tantas veces como se desee, para cambiar su valor. En Python, las variables no tienen tipos específicos, por lo que se puede asignar una cadena a una variable y luego asignar un número entero a la misma variable.

\pythonfile{codigo/4-variables/variable_4.py}
\out{codigo/4-variables/variable_4.out}

Sin embargo, no es una buena práctica. Para evitar errores, se debería evitar sobreescribir una variable con distintos tipos de datos.\smallskip

%TODO: enlaces a numérico y alfanumérico
Si se asigna el valor numérico (enteros y decimales) o alfanumérico (cadena de texto) de una variable a otra, los cambios hechos a ambas variables son independientes.

\pythonfile{codigo/4-variables/variable_5.py}
\out{codigo/4-variables/variable_5.out}

Esto no ocurre para tipos de datos más complejos, como listas.

\section{Entrada}

Para obtener información del usuario, se puede usar la función \ttt{input()}, la cual solicita al usuario que la entrada. La información obtenida puede ser almacenada como una variable.

\pythonfile{codigo/4-variables/input_1.py}
\inp{codigo/4-variables/input_1.inp}
\out{codigo/4-variables/input_1.out}

Toda la información recibida por el método \ttt{input()} se procesa como un string.\smallskip

También se puede entregar un string como parámetro al método \ttt{input()}, lo cual mostrará texto antes de pedir la entrada. Esto sirve para aclarar qué entrada está solicitando el programa.

\pythonfile{codigo/4-variables/input_2.py}

Al usar la función \ttt{input()}, el flujo del programa se detiene hasta que el usuario ingrese algún valor.\smallskip

Se puede usar \ttt{input()} varias veces para tomar múltiples entradas del usuario.

\pythonfile{codigo/4-variables/input_multiple.py}
\inp{codigo/4-variables/input_multiple.inp}
\out{codigo/4-variables/input_multiple.out}

Normalmente, se debe añadir un espacio para concatenar variables, para evitar que las variables aparezcan juntas en la salida.

\section{Conversión de tipos de datos}

Existen funciones para convertir datos de un tipo a otro. Entre dichas funciones se encuentran:

\begin{itemize}
  \item \ttt{int()}: Convierte a un número entero.
  
  \pythonfile{codigo/4-variables/convertir_a_int_1.py}
  \out{codigo/4-variables/convertir_a_int_1.out}

  Aunque ambos se impriman igual, el primero es un string y el segundo un entero (int).

  \pythonfile{codigo/4-variables/convertir_a_int_2.py}
  \out{codigo/4-variables/convertir_a_int_2.out}

  Al convertir de \ttt{float} a \ttt{int}, sólo se conservará la parte entera del número. No ocurrirá ningún tipo de redondeo.

  \pythonfile{codigo/4-variables/float_a_int.py}
  \out{codigo/4-variables/float_a_int.out}

  \item \ttt{float()}: Convierte a un float.
  
  \pythonfile{codigo/4-variables/convertir_a_float.py}
  \out{codigo/4-variables/convertir_a_float.out}

  \item \ttt{str()}: Convierte a un string o cadena de caracteres. Uno de sus usos principales es para concatenar distintos tipos de datos.

  \pythonfile{codigo/4-variables/convertir_a_string.py}
  \out{codigo/4-variables/convertir_a_string.out}

\end{itemize}

Como el resultado de la función \ttt{input()} es un string, es normal convertir el resultado de este método para usarlo en operaciones matemáticas.

\pythonfile{codigo/4-variables/input_3.py}
\inp{codigo/4-variables/input_3.inp}
\out{codigo/4-variables/input_3.out}

\section{Operadores de asignación}

Los operadores de asignación permiten escribir código como \ttt{x = x + 1} de manera más concisa, como \ttt{x += 1}. Lo mismo es posible con otros operadores como \ttt{-}, \ttt{*}, \ttt{/}, \ttt{//}, \ttt{\%} y \ttt{**}.

\pythonfile{codigo/4-variables/asignacion_1.py}

También se pueden usar con los operadores de concatenación y multiplicación de strings.

\pythonfile{codigo/4-variables/asignacion_2.py}

\section{Tipos de datos}

En Python existen muchos tipos de datos que pueden ser usados y almacenados como variables. La función \ttt{type()} retorna el tipo de dato del objeto que se le entrega como argumento.\smallskip

A continuación se mostrarán los tipos de datos más comunes.

\begin{itemize}
  \item Número entero \ttt{int}
  
  \pythonfile{codigo/4-variables/tipo_int.py}
  \out{codigo/4-variables/tipo_int.out}

  \item Número racional \ttt{float}
  
  \pythonfile{codigo/4-variables/tipo_float.py}
  \out{codigo/4-variables/tipo_float.out}

  \item Cadena de caracteres \ttt{str}
  
  \pythonfile{codigo/4-variables/tipo_str.py}
  \out{codigo/4-variables/tipo_str.out}

  \item Booleano \ttt{bool}
  
  \pythonfile{codigo/4-variables/tipo_bool.py}
  \out{codigo/4-variables/tipo_bool.out}

  \item Lista \ttt{list}
  
  \pythonfile{codigo/4-variables/tipo_list.py}
  \out{codigo/4-variables/tipo_list.out}

  \item Rango \ttt{range}
  
  \pythonfile{codigo/4-variables/tipo_range.py}
  \out{codigo/4-variables/tipo_range.out}

  \item Función \ttt{function}
  
  \pythonfile{codigo/4-variables/tipo_function.py}
  \out{codigo/4-variables/tipo_function.out}

  \item Número complejo \ttt{complex}
  
  \pythonfile{codigo/4-variables/tipo_complex.py}
  \out{codigo/4-variables/tipo_complex.out}

  \item Diccionario \ttt{dict}
  
  \pythonfile{codigo/4-variables/tipo_dict.py}
  \out{codigo/4-variables/tipo_dict.out}

  \item Tupla \ttt{tuple}
  
  \pythonfile{codigo/4-variables/tipo_tuple.py}
  \out{codigo/4-variables/tipo_tuple.out}

  \item Conjunto \ttt{set}
  
  \pythonfile{codigo/4-variables/tipo_set.py}
  \out{codigo/4-variables/tipo_set.out}

  \item Frozenset \ttt{frozenset}
  
  \pythonfile{codigo/4-variables/tipo_frozenset.py}
  \out{codigo/4-variables/tipo_frozenset.out}

\end{itemize}

Estos tipos y muchos más se verán en detalle en los próximos capítulos.

\clearpage\chapter{Declaraciones if y lógica}

\section{Booleanos}

Otro tipo de dato en Python es el tipo booleano, el cual sólo puede tener 2 valores: \ttt{True} para representar valores verdaderos y \ttt{False} para representar valores falsos. Estos se escriben empezando con mayúscula, al contrario de otros lenguajes de programación.\smallskip

Se pueden crear directamente, aunque esto no tiene mucha utilidad en la mayoría de casos.

\pythonfile{codigo/5-if/booleano_1.py}
\out{codigo/5-if/booleano_1.out}

Su uso más común es como el resultado obtenido al comparar valores, por ejemplo, usando el operador de igualdad \ttt{==}.

\pythonfile{codigo/5-if/booleano_2.py}
\out{codigo/5-if/booleano_2.out}

Se debe tener cuidado de no confundir el operador de asignación \ttt{=} con el operador de igualdad \ttt{==}.\smallskip

En Python, \ttt{1} y \ttt{True} significan lo mismo. Lo mismo ocurre con \ttt{0} y \ttt{False}.

\pythonfile{codigo/5-if/booleano_3.py}
\out{codigo/5-if/booleano_3.out}

Usando otros términos, podría decirse que \ttt{1} es \link{https://stackoverflow.com/questions/39983695/what-is-truthy-and-falsy-how-is-it-different-from-true-and-false}{\doble{truthy}} y que \ttt{0} es \link{https://stackoverflow.com/questions/39983695/what-is-truthy-and-falsy-how-is-it-different-from-true-and-false}{\doble{falsy}}.

Esta equivalencia también es válida para floats.

\pythonfile{codigo/5-if/booleano_4.py}
\out{codigo/5-if/booleano_4.out}

\section{Conversión a boooleanos}

La función \ttt{bool()} se puede usar para convertir un objeto a su valor booleano.\smallskip

Al usarla con valores numéricos, el número \ttt{0} se convierte a \ttt{False} y cualquier otro número se convierte a \ttt{True}.

\pythonfile{codigo/5-if/bool_1.py}
\out{codigo/5-if/bool_1.out}

Una cadena de texto vacía se convierte en \ttt{False} y cualquier cadena que no sea vacía se convierte en \ttt{True}.

\pythonfile{codigo/5-if/bool_2.py}
\out{codigo/5-if/bool_2.out}

La misma situación ocurre al convertir tipos de datos más complejos, los cuales no se han visto todavía.

\pythonfile{codigo/5-if/bool_3.py}
\out{codigo/5-if/bool_3.out}

\section{Operadores de comparación}

Los operadores de comparación usados en Python son los siguientes:

\begin{itemize}
  \item Igual $=$, escrito como \ttt{==}: Se evalúa como \ttt{True} si ambos elementos son iguales.
  
  \item Distinto $\neq$, escrito como \ttt{!=}: Se evalúa como \ttt{True} si ambos elementos son distintos.
  
  \item Mayor que $>$, escrito como \ttt{>}: Se evalúa como \ttt{True} si el primer elemento es mayor.
  
  \item Menor que $<$, escrito como \ttt{<}: Se evalúa como \ttt{True} si el primer elemento es menor.
  
  \item Mayor o igual que $\geq$, escrito como \ttt{>=}: Se evalúa como \ttt{True} si el primer elemento es mayor o igual al segundo.
  
  \item Menor o igual que $\leq$, escrito como \ttt{<=}: Se evalúa como \ttt{True} si el primer elemento es menor o igual al segundo.
  
\end{itemize}

En los casos contrarios, los operadores retornan \ttt{False}.\smallskip

Ejemplos de uso de operadores de comparación:

\pythonfile{codigo/5-if/comparacion_1.py}
\out{codigo/5-if/comparacion_1.out}

También se conocen como operadores relacionales.\smallskip

Las comparaciones entre datos de tipo entero y float también son válidas.

\pythonfile{codigo/5-if/comparacion_2.py}
\out{codigo/5-if/comparacion_2.out}

Las comparaciones entre números y strings son válidas, pero siempre se evalúan como \ttt{False}.

\pythonfile{codigo/5-if/comparacion_3.py}
\out{codigo/5-if/comparacion_3.out}

\section{Comparación entre strings}

Los operadores \ttt{==} y \ttt{!=} funcionan entre strings como se esperaría.

\pythonfile{codigo/5-if/comparacion_string_1.py}
\out{codigo/5-if/comparacion_string_1.out}

Los operadores \ttt{>}, \ttt{<}, \ttt{>=} y \ttt{<=} también se pueden usar para comparar cadenas lexicográficamente (por orden alfabético), donde las palabras que están después se consideran \doble{mayores}.

\pythonfile{codigo/5-if/comparacion_string_2.py}
\out{codigo/5-if/comparacion_string_2.out}

Las letras mayúsculas siempre irán antes (son \doble{menores}) que las minúsculas al ordenarlas alfabéticamente.

\pythonfile{codigo/5-if/comparacion_string_3.py}
\out{codigo/5-if/comparacion_string_3.out}

Específicamente, Python compara los códigos \link{https://www.ascii-code.com}{ASCII} para ordenar las cadenas de textos.

\section{Declaración if}

Las declaraciones \ttt{if} sirven para ejecutar código si ser cumple una determinada condición. Si la expresión se evalúa como \ttt{True}, se lleva a cabo el bloque de código que le sigue. En caso contrario, no ocurre nada.

\pythonfile{codigo/5-if/if.py}
\out{codigo/5-if/if.out}

\section{Indentación}

Python usa indentación (espacio en blanco al comienzo de una línea) para delimitar bloques de código. En otros lenguajes, esta operación se realiza delimitando cada bloque de código por llaves \ttt{\{\}}.\smallskip

Para que el intérprete reconozca los bloques de código correctamente, cada instrucción dentro de un mismo bloque de código debe escribirse a un mismo nivel de indentación.\smallskip

A continuación se muestra un ejemplo que no cumple con eso. Para que se entienda el concepto mejor, en cada segmento de código en esta sección se mostrarán los espacios en blanco.

\pythonspaces{codigo/5-if/error_indentacion_1.py}
\out{codigo/5-if/error_indentacion_1.out}

No se permite mezclar espacios con saltos de tabulador (los que aparecen al pulsar la tecla \ttt{Tab}). Aunque se vean igual, dependiendo de las configuraciones, un salto de tabulador puede cambiar de medida. La medida de un espacio es siempre la misma, así que se recomienda usarlos en vez del tabulador.\smallskip

A continuación se muestra un ejemplo que parece ser válido a simple vista, pero no lo es ya que tiene un salto de tabulador en la linea \ttt{print("mundo")} y 4 espacios en las otras líneas.

\pythonspaces{codigo/5-if/error_indentacion_2.py}
\out{codigo/5-if/error_indentacion_2.out}

Pára evitar que esto ocurra, muchos IDEs tienen la opción \doble{insertar espacios al presionar la tecla \ttt{Tab}}, para insertar 4 espacios (o la cantidad que se desee) al pulsar dicha tecla.\smallskip

Por último, aunque esto no es un error de por sí (no se lanza ninguna excepción), se recomienda mantener la cantidad de espacios usados para cada indentación consistente, es decir, que no varíe su cantidad.\smallskip

El siguiente ejemplo muestra una práctica que se debe evitar.

\pythonspaces{codigo/5-if/error_indentacion_3.py}
\out{codigo/5-if/error_indentacion_3.out}

No existe una cantidad \doble{correcta} de espacios para indentar, aunque la mayoría de programadores prefiere que sean 2, 3 o 4 (en Python). Lo más importante es que se escoja una cantidad y se mantenga igual dentro de un mismo proyecto.\smallskip

Los errores de indentación son más fáciles de evitar que de encontrar, así que como dice el dicho, \doble{mejor prevenir que lamentar}.

\section{Anidación de declaraciones if}

Para realizar comprobaciones más complejas, las declaraciones \ttt{if} se pueden anidar, una dentro de la otra.\smallskip

Esto significa que la declaración \ttt{if} interna sólo se evalúa si la declaración \ttt{if} externa es válida.

\pythonfile{codigo/5-if/if_anidado.py}
\out{codigo/5-if/if_anidado.out}

\section{Declaración if-else}

Las declaraciones \ttt{if-else} son muy similares a las declaraciones \ttt{if}, pero esta vez sí ocurre algo cuando no se cumple la expresión a evaluar.

\pythonfile{codigo/5-if/if_else_1.py}
\out{codigo/5-if/if_else_1.out}

\pythonfile{codigo/5-if/if_else_2.py}
\inp{codigo/5-if/if_else_2.inp_1}
\out{codigo/5-if/if_else_2.out_1}
\inp{codigo/5-if/if_else_2.inp_1}
\out{codigo/5-if/if_else_2.out_1}

\section{Declaración elif}

Cada declaración \ttt{if} sólo puede tener una declaración \ttt{else} que la acompañe, lo cual puede resultar muy incómodo.

\pythonfile{codigo/5-if/if_else_anidado.py}
\out{codigo/5-if/if_else_anidado.out}

El término \ttt{elif} se usa para evitar tener que anidar múltiples declaraciones \ttt{if-else}. Hace que el código sea más corto.

\pythonfile{codigo/5-if/elif.py}
\inp{codigo/5-if/elif.inp_1}
\out{codigo/5-if/elif.out_1}
\inp{codigo/5-if/elif.inp_2}
\out{codigo/5-if/elif.out_2}

El programa irá evaluando cada expresión una por una hasta que alguna se cumpla. Cuando esto ocurra, ejecutará las instrucciones en su bloque de código y continuará con las expresiones después del bloque de código \ttt{else}.

\section{Operadores lógicos}

Los operadores lógicos se utilizan para crear condiciones complejas agrupando condiciones más simples. Los operadores lógicos que se usan en Python son \ttt{and}, \ttt{or} y \ttt{not}.\smallskip

El operador \ttt{and} se evalúa como \ttt{True} si ambas condiciones se cumplen.

\pythonfile{codigo/5-if/and.py}
\out{codigo/5-if/and.out}

El operador \ttt{or} se evalúa como \ttt{True} si al menos una de las condiciones se cumple.

\pythonfile{codigo/5-if/or.py}
\out{codigo/5-if/or.out}

El operador \ttt{not} sólo toma una condición y la invierte.

\pythonfile{codigo/5-if/not.py}
\out{codigo/5-if/not.out}

\section{Precedencia de operadores lógicos}

Los operadores lógicos siguen un orden similar a PEMDAS, el cual es el siguiente:

\begin{enumerate}
  \item Paréntesis \ttt{()}
  
  \item Operador \ttt{not}
  
  \item Operador \ttt{and}
  
  \item Operador \ttt{or}
  
\end{enumerate}

Sin embargo, este orden es confuso, por lo que se recomienda usar paréntesis para hacerlo más obvio, incluso si es redundante.

\pythonfile{codigo/5-if/logica.py}
\out{codigo/5-if/logica.out}

\clearpage\chapter{Listas}

\section{Creación de listas}

Las listas se utilizan para almacenar varios elementos. Se crean utilizando corchetes y separando los elementos por comas.

\pythonfile{codigo/6-listas/lista_1.py}

En Python, las listas pueden tener elementos de más de un tipo.

\pythonfile{codigo/6-listas/lista_2.py}

\section{Indexación de listas}

Se puede acceder a un determinado elemento de la lista utilizando su índice entre corchetes. El índice del primer elemento es \ttt{0}, en lugar de \ttt{1}, como podría esperarse.

\pythonfile{codigo/6-listas/indexar_listas_1.py}
\out{codigo/6-listas/indexar_listas_1.out}

Alternativamente, se pueden usar índices negativos. El último elemento de una lista tiene índice \ttt{-1}, el anterior \ttt{-2}, y así sucesivamente hasta llegar al primero.

\pythonfile{codigo/6-listas/indexar_listas_2.py}
\out{codigo/6-listas/indexar_listas_2.out}

\section{IndexError en listas}

Intentar acceder a un índice no existente producirá un error.

\pythonfile{codigo/6-listas/error_indice.py}
\out{codigo/6-listas/error_indice.out}

\section{Lista vacía}

A veces es necesario crear una lista vacía y completarla más tarde durante la ejecución del programa. Las listas vacías se crean con un par de corchetes vacíos \ttt{[]}.

\pythonfile{codigo/6-listas/lista_vacia.py}

\section{Anidación de listas}

Las listas se pueden anidar dentro de otras listas, y para acceder a algún elemento se debe usar una cantidad mayor de corchetes, donde los índices indican el elemento desde afuera hacia adentro.

\pythonfile{codigo/6-listas/anidacion.py}
\out{codigo/6-listas/anidacion.out}

En el ejemplo de arriba se muestra como acceder a todos los elementos de la lista creada.\smallskip

Las listas anidadas se pueden utilizar para representar cuadrículas 2D, como por ejemplo \link{https://es.khanacademy.org/math/algebra-home/alg-matrices}{matrices}.

\pythonfile{codigo/6-listas/identidad.py}

El intérprete ignora los saltos de línea y la indentación dentro de los corchetes \ttt{[]}.\smallskip

Esta estructura tipo matriz es muy conveniente en los casos en los que se necesite almacenar datos en formato tabla (fila-columna).

\section{Comas sobrantes}

Se puede dejar a lo más una coma sobrante dentro de los corchetes de una lista. Este último elemento no será añadido a la lista.

\pythonfile{codigo/6-listas/comas.py}
\out{codigo/6-listas/comas.out}

Si se deja más de una coma, se mostrará un \ttt{SyntaxError}.

\pythonfile{codigo/6-listas/error_comas.py}
\out{codigo/6-listas/error_comas.out}

\section{Operaciones con listas}

El elemento en un índice determinado de una lista se puede reasignar.

\pythonfile{codigo/6-listas/operaciones_listas_1.py}
\out{codigo/6-listas/operaciones_listas_1.out}

Las listas se pueden agregar y multiplicar de la misma manera que las cadenas.

\pythonfile{codigo/6-listas/operaciones_listas_2.py}
\out{codigo/6-listas/operaciones_listas_2.out}

\section{Operadores in y not in}

Se puede verificar si un elemento pertenece a una lista usando el operador \ttt{in}. Este devuelve \ttt{True} si dicho elemento aparece una o más veces en la lista y \ttt{False} si no es así.

\pythonfile{codigo/6-listas/in.py}
\out{codigo/6-listas/in.out}

Para comprobar si un elemento no pertenece a una lista, se pueden combinar los operadores \ttt{in} y \ttt{not}. Ambas formas mostradas a continuación son válidas.

\pythonfile{codigo/6-listas/not_in.py}
\out{codigo/6-listas/not_in.out}

\section{Funciones de listas}

Existen métodos que sirven para trabajar con listas.

\begin{itemize}
  \item El método \ttt{append()} se usa para añadir un elemento al final de una lista.
  
  \pythonfile{codigo/6-listas/append.py}
  \out{codigo/6-listas/append.out}

  \item El método \ttt{pop()} elimina el último elemento de una lista.
  
  \pythonfile{codigo/6-listas/pop_1.py}
  \out{codigo/6-listas/pop_1.out}

  Se le puede entregar un argumento numérico para quitar elementos de una lista según su índice. Este número puede ser negativo.

  \pythonfile{codigo/6-listas/pop_2.py}
  \out{codigo/6-listas/pop_2.out}

  \item El método \ttt{len()} retorna el tamaño (número de elementos) de una lista.
  
  \pythonfile{codigo/6-listas/len.py}
  \out{codigo/6-listas/len.out}

  \item El método \ttt{insert()} se usa para insertar un elemento en un índice específico de una lista. Los elementos que están después del elemento insertado se desplazan a la derecha.

  \pythonfile{codigo/6-listas/insert.py}
  \out{codigo/6-listas/insert.out}

  \item El método \ttt{extend()} se usa para añadir todos los elementos de una lista al final de otra lista.
  
  \pythonfile{codigo/6-listas/extend.py}
  \out{codigo/6-listas/extend.out}

  \item El método \ttt{index()} encuentra la primera aparición de un elemento en una lista y devuelve su índice.
  
  \pythonfile{codigo/6-listas/index.py}
  \out{codigo/6-listas/index.out}

  Si el elemento no está en la lista, muestra un \ttt{ValueError}.

  \pythonfile{codigo/6-listas/error_index.py}
  \out{codigo/6-listas/error_index.out}

  \item El método \ttt{count()} cuenta la cantidad de ocurrencias de un elemento en una lista.
  
  \pythonfile{codigo/6-listas/count.py}
  \out{codigo/6-listas/count.out}

  \item El método \ttt{remove()} elimina la primera ocurrencia de un elemento en una lista.
  
  \pythonfile{codigo/6-listas/remove_1.py}
  \out{codigo/6-listas/remove_1.out}

  Si el elemento no existe en la lista, levanta un \ttt{ValueError}.

  \pythonfile{codigo/6-listas/error_remove.py}
  \out{codigo/6-listas/error_remove.out}

  Una forma más segura de usar \ttt{remove()} es la siguiente:

  \pythonfile{codigo/6-listas/remove_2.py}
  \out{codigo/6-listas/remove_2.out}

  \item Los métodos \ttt{max()} y \ttt{min()} devuelven el elemento de una lista con valor máximo o mínimo, respectivamente.

  \pythonfile{codigo/6-listas/max_y_min_1.py}
  \out{codigo/6-listas/max_y_min_1.out}

  Si son strings, los compara por orden alfabético. Se considera como \doble{mayor} a las palabras que se encuentran al final después de ordenarlas alfabéticamente.

  \pythonfile{codigo/6-listas/max_y_min_2.py}
  \out{codigo/6-listas/max_y_min_2.out}

  \item El método \ttt{sum()} calcula la suma de los elementos de una lista.
  
  \pythonfile{codigo/6-listas/sum.py}
  \out{codigo/6-listas/sum.out}

  \item El método \ttt{reverse()} invierte los elementos de una lista.
  
  \pythonfile{codigo/6-listas/reverse.py}
  \out{codigo/6-listas/reverse.out}

  \item El método \ttt{sort()} ordena alfabéticamente una lista de strings, por defecto se realiza ascendentemente. Para realizar el orden descendentemente, se debe entregar el parámetro \ttt{reverse=True}.
  
  \pythonfile{codigo/6-listas/sort_letras.py}
  \out{codigo/6-listas/sort_letras.out}
  
  También funciona con listas compuestas de números.

  \pythonfile{codigo/6-listas/sort_numeros.py}
  \out{codigo/6-listas/sort_numeros.out}

  Si se usa en listas mixtas, mostrará un \ttt{TypeError}.

  \pythonfile{codigo/6-listas/sort_mixto.py}
  \out{codigo/6-listas/sort_mixto.out}

  \item El método \ttt{clear()} quita todos los elementos de una lista.

  \pythonfile{codigo/6-listas/clear.py}
  \out{codigo/6-listas/clear.out}

\end{itemize}

\section{Copiar listas}

Al intentar copiar listas sólo usando su nombre, en realidad se está haciendo una lista que hace referencia a la lista copiada. Esto significa que los cambios que reciba una lista también los recibirá la otra.

\pythonfile{codigo/6-listas/copy_1.py}
\out{codigo/6-listas/copy_1.out}

Para evitar esto, se puede usar el método \ttt{copy()} para hacer una copia de una lista en una nueva instancia.

\pythonfile{codigo/6-listas/copy_2.py}
\out{codigo/6-listas/copy_2.out}

Otra opción válida es usando el constructor \ttt{list()}.

\pythonfile{codigo/6-listas/copy_list.py}
\out{codigo/6-listas/copy_list.out}

\section{Strings como listas}

Las cadenas pueden verse como listas de caracteres que no se pueden cambiar (inmutables).

\pythonfile{codigo/6-listas/strings_vs_listas.py}

De hecho, tienen muchas similitudes, de las cuales se verán algunas a continuación.

\section{Indexación de strings}

Algunos tipos de variables, como las cadenas, se pueden indexar como listas. La indexación de cadenas se comporta como si estuviera indexando una lista que contiene cada carácter de la cadena.

\pythonfile{codigo/6-listas/strings_como_listas.py}
\out{codigo/6-listas/strings_como_listas.out}

Se debe recordar que el espacio \ttt{\qq  \qq} también es considerado como símbolo y tiene su índice dentro de la cadena.\smallskip

\section{Reasignación de strings}

Las cadenas son inmutables, lo que significa que no se pueden reasignar sus caracteres.

\pythonfile{codigo/6-listas/error_cadenas.py}
\out{codigo/6-listas/error_cadenas.out}

La única forma de solucionar este problema es creando una nueva cadena con el cambio que se quería.

\pythonfile{codigo/6-listas/solucion_cadenas.py}
\out{codigo/6-listas/solucion_cadenas.out}

\section{Conversión de strings a listas}

El método \ttt{list()} convierte una cadena de caracteres en una lista de caracteres.

\pythonfile{codigo/6-listas/list.py}
\out{codigo/6-listas/list.out}

El método \ttt{split()} convierte una cadena de caracteres en una lista de palabras, separadas por espacios \ttt{\qq  \qq}.

\pythonfile{codigo/6-listas/split.py}
\out{codigo/6-listas/split.out}

\clearpage\chapter{Bucles}

\section{Bucles while}

Un bucle \ttt{while} se usa para repetir un bloque de código varias veces, siempre que se cumpla cierta condición. Generalmente se usan con una variable como contador.

\pythonfile{codigo/7-bucles/while_1.py}
\out{codigo/7-bucles/while_1.out}

El código en el cuerpo de un bucle \ttt{while} se ejecuta repetidamente. Esto se llama iteración.\smallskip

Se puede realizar cualquier operación con el contador dentro del bucle.

\pythonfile{codigo/7-bucles/while_2.py}
\out{codigo/7-bucles/while_2.out}

\pythonfile{codigo/7-bucles/while_3.py}
\out{codigo/7-bucles/while_3.out}

\section{Bucles infinitos}

Si la condición a evaluar es siempre verdadera, el bucle se ejecutará indefinidamente. Esto se llama bucle infinito.

\pythonfile{codigo/7-bucles/while_infinito.py}
\out{codigo/7-bucles/while_infinito.out}

No se recomienda ejecutar este código. Si por algún motivo se ejecuta, se puede interrumpir su ejecución enviando un \ttt{KeyboardInterrupt} al usar la combinación de teclas \ttt{Ctrl+C}.

\section{Declaración break}

Para finalizar un bucle \ttt{while} prematuramente, se puede usar la declaración \ttt{break}.

\pythonfile{codigo/7-bucles/break.py}
\out{codigo/7-bucles/break.out}

El uso de la declaración \ttt{break} fuera de un bucle provoca un error.

\pythonfile{codigo/7-bucles/error_break.py}
\out{codigo/7-bucles/error_break.out}

\section{Declaración continue}

Otra declaración que se puede utilizar dentro de los bucles es \ttt{continue}. A diferencia de \ttt{break}, \ttt{continue} salta de nuevo a la parte superior del bucle, en lugar de detenerlo. Básicamente, la declaración \ttt{continue} detiene la iteración actual y continúa con la siguiente.

\pythonfile{codigo/7-bucles/continue.py}
\out{codigo/7-bucles/continue.out}

Al igual que la declaración \ttt{break}, usar \ttt{continue} fuera de un bucle provoca un error.

\pythonfile{codigo/7-bucles/error_continue.py}
\out{codigo/7-bucles/error_continue.out}

\section{Bucle for con listas}

Otro tipo de bucle es el bucle \ttt{for}. Estos bucles se pueden usar para iterar sobre una lista. Las instrucciones dentro de su bloque de código se ejecutarán para cada elemento de la lista.

\pythonfile{codigo/7-bucles/for_1.py}
\out{codigo/7-bucles/for_1.out}

También se puede usar para iterar sobre cadenas.

\pythonfile{codigo/7-bucles/for_2.py}
\out{codigo/7-bucles/for_2.out}

De manera similar a los bucles \ttt{while}, las declaraciones \ttt{break} y \ttt{continue} se pueden utilizar en los bucles \ttt{for} para detener el bucle o saltar a la siguiente iteración.

\pythonfile{codigo/7-bucles/for_3.py}
\out{codigo/7-bucles/for_3.out}

\section{Rangos}

La función \ttt{range()} devuelve una secuencia de números.\smallskip

Si se llama a \ttt{range()} con un argumento, produce un objeto con valores desde \ttt{0} hasta el antecesor del número especificado.

\pythonfile{codigo/7-bucles/range_solo.py}
\out{codigo/7-bucles/range_solo.out}

Para mostrar los números dentro de un objeto range, debe convertirse a una lista usando el método \ttt{list()}.

\pythonfile{codigo/7-bucles/range_1.py}
\out{codigo/7-bucles/range_1.out}

Si se llama con 2 argumentos, produce valores desde el primero hasta el antecesor del segundo.

\pythonfile{codigo/7-bucles/range_2.py}
\out{codigo/7-bucles/range_2.out}

Si el primer número es \ttt{0}, el resultado es equivalente al de ingresar sólo 1 argumento.

\pythonfile{codigo/7-bucles/range_3.py}
\out{codigo/7-bucles/range_3.out}

El rango puede tener un tercer argumento, que determina el intervalo de la secuencia producida, también llamado como paso. Este número puede ser positivo (incremento) o negativo (decremento).

\pythonfile{codigo/7-bucles/range_4.py}
\out{codigo/7-bucles/range_4.out}

\section{Rangos imposibles}

Intentar almacenar rangos \doble{imposibles} no mostrará ningún error. El rango simplemente no tendrá ningún elemento, lo cual es más fácil de ver al convertirlo en una lista.

\pythonfile{codigo/7-bucles/rango_imposible.py}
\out{codigo/7-bucles/rango_imposible.out}

\section{Bucle for en rangos}

Una forma común de usar los bucles \ttt{for} es iterando sobre rangos. Esto permite hacer bucles de muchas formas.

\pythonfile{codigo/7-bucles/for_rango.py}
\out{codigo/7-bucles/for_rango.out}

No es necesario llamar \ttt{list()} en el objeto de rango cuando se usa en un bucle \ttt{for}, porque no se está indexando, por lo que no requiere una lista.\smallskip

En general, un bucle \ttt{for} puede recorrer cualquier iterable. Estos se verán más a fondo en su propio capítulo.

\clearpage\chapter{Funciones}

\section{Reutilización de código}

La reutilización de código es una parte muy importante de la programación en cualquier lenguaje. Incrementar el tamaño del código lo hace más difícil de mantener.\smallskip

Para que un proyecto grande de programación sea exitoso, es esencial que se atenga al principio DRY, del inglés Don't Repeat Yourself (no te repitas).\smallskip

Del código malo y repetitivo, se dice que se atiene al principio WET, del inglés Write Everything Twice (escribe todo dos veces) o We Enjoy Typing (disfrutamos escribir).\smallskip

Los bucles vistos en el capítulo anterior son una forma de reutilizar código. Este capítulo trata sobre funciones, que son otra forma de hacer esta práctica.

\section{Funciones}

Cualquier sentencia que consista de una palabra seguida de información entre paréntesis es llamada una función.\smallskip

Ejemplos de funciones que se han visto anteriormente:

\pythonfile{codigo/8-funciones/funciones.py}

Palabras antes del paréntesis son nombres de funciones y los valores separados por comas dentro de los paréntesis son argumentos o parámetros de funciones.

\section{Definición de funciones}

Para definir una función, se debe usar la palabra clave \ttt{def}, seguida del nombre de la función y de un paréntesis que puede o no incluir parámetros. El cuerpo de la función incluye el código y debe tener un grado de indentación mayor que el de la definición.\smallskip

Generalmente, se recomienda que el nombre de una función sea un verbo, pero no es obligatorio.\smallskip

Ejemplo de definición de función:

\pythonfile{codigo/8-funciones/saludar.py}

\section{Argumentos}

Las funciones más básicas son las que no reciben argumentos, pero esto limita su utilidad en gran cantidad. Para hacerlas más útiles, se les puede entregar argumentos, lo que aumenta su funcionalidad.

\pythonfile{codigo/8-funciones/exclamar.py}

Una función puede pedir más de un argumento, los cuales deben separarse por comas.

\pythonfile{codigo/8-funciones/sumar.py}

\pythonfile{codigo/8-funciones/mayor.py}

Los argumentos de funciones pueden ser utilizados como variables dentro de la definición de la función. Sin embargo, no pueden ser referenciados fuera de la definición de la función. Esto también se aplica a las demás variables creadas dentro de una función.

\pythonfile{codigo/8-funciones/argumentos.py}
\out{codigo/8-funciones/argumentos.out}

\section{Llamado de funciones}

Para llamar una función, debe escribirse su nombre, seguido de un paréntesis que contiene los argumentos (información) que se le quieren entregar.\smallskip

Ejemplos de uso de las funciones definidas anteriormente:

\pythonfile{codigo/8-funciones/llamar_saludar.py}
\out{codigo/8-funciones/llamar_saludar.out}

\pythonfile{codigo/8-funciones/llamar_exclamar.py}
\out{codigo/8-funciones/llamar_exclamar.out}

\pythonfile{codigo/8-funciones/llamar_sumar.py}
\out{codigo/8-funciones/llamar_sumar.out}

\pythonfile{codigo/8-funciones/llamar_mayor.py}
\out{codigo/8-funciones/llamar_mayor.out}

Técnicamente, los parámetros son las variables en una definición de función y los argumentos son los valores que se le dan a las variables al momento de llamar funciones.

\section{Devolución de valores en una función}

Ciertas funciones devuelven un valor para ser utilizado más adelante. Para hacer esto en la definición de funciones nuevas, se debe usar la palabra clave \ttt{return}.

\pythonfile{codigo/8-funciones/return_1.py}
\out{codigo/8-funciones/return_1.out}

Cualquier código luego de la sentencia \ttt{return} nunca ocurrirá.

\pythonfile{codigo/8-funciones/return_2.py}
\out{codigo/8-funciones/return_2.out}

\section{Docstring}

Las docstring (cadenas de documentación) cumplen un propósito similar al de los comentarios, pero son más específicos y tienen una sintaxis distinta.\smallskip

Son creados colocando una cadena multilínea que contenga una explicación de la función por debajo de la primera línea de la función y teniendo cuidado de respetar la indentación.

\pythonfile{codigo/8-funciones/docstring_1.py}

Normalmente se usan docstrings para explicar los parámetros y lo que retorna una función.

%TODO: buscar formato aceptado
\pythonfile{codigo/8-funciones/docstring_2.py}

El intérprete de Python ignora los docstring que se usen en otros lugares. Esto ha hecho que algunas personas los usen como \doble{comentarios multilínea}, pero en la práctica no se recomienda hacer esto porque puede generar confusión.

\pythonfile{codigo/8-funciones/comentario_malo.py}

También podría generar problemas de indentación en algunos casos.

\section{Revisar documentación} %TODO: revisar más info aquí

A diferencia de los comentarios convencionales, los docstring se conservan a lo largo del tiempo de ejecución del programa. Esto le permite al programador examinar estos comentarios durante el tiempo de ejecución.\smallskip

Una forma de accederlo es usando la variable \ttt{\_\_doc\_\_}.

\pythonfile{codigo/8-funciones/print_doc.py}
\out{codigo/8-funciones/print_doc.out}

Otra forma es usando la función \ttt{help()}. Esto entrega un poco más de información.

\pythonfile{codigo/8-funciones/help.py}
\out{codigo/8-funciones/help.out}

\section{Funciones como objetos}

Aunque sean creadas de manera diferente que las variables regulares, las funciones son como cualquier otra clase de valor. Pueden ser asignadas y reasignadas a variables, y luego ser referenciadas por esos nombres.

\pythonfile{codigo/8-funciones/funcion_como_objeto_1.py}
\out{codigo/8-funciones/funcion_como_objeto_1.out}

Las funciones también pueden ser usadas como argumentos de otras funciones.

\pythonfile{codigo/8-funciones/funcion_como_objeto_2.py}
\out{codigo/8-funciones/funcion_como_objeto_2.out}

\section{El objeto None}

El objeto \ttt{None} es utilizado para representar la ausencia de un valor. Es similar a \ttt{null} en otros lenguajes de programación.\smallskip

Al igual que otros valores \doble{vacíos}, tales como \ttt{()}, \ttt{[]}, \ttt{\{\}} y la cadena vacía \ttt{\qq \qq} o \ttt{\q \q}, es \ttt{False} cuando es convertido a una variable booleana.

%TODO: ejemplo y mencionar estructuras de datos

Cuando es ingresado a la consola de Python, se visualiza como una cadena vacía. Usando \ttt{print()} se mostrará su verdadero valor.

\pythonfile{codigo/8-funciones/None_1.py}
\out{codigo/8-funciones/None_1.out}

El objeto \ttt{None} es devuelto por cualquier función que no devuelve explícitamente algo más.

\pythonfile{codigo/8-funciones/None_2.py}
\out{codigo/8-funciones/None_2.out}

Un uso común de \ttt{None} es para iniciar una lista con cierta cantidad de elementos.

\pythonfile{codigo/8-funciones/None_3.py}
\out{codigo/8-funciones/None_3.out}

\section{Sobrecarga de funciones}

En Python, la sobrecarga de funciones se define como la habilidad de que una función se comporte de distinta manera dependiendo del número de argumentos que reciba. Esto permite reutilizar el mismo código, reducir su complejidad y hacer que sea más fácil de leer.\smallskip

Para sobrecargar una función, se deben definir los parámetros que sean opcionales con un valor por defecto \ttt{None}. Después, se usan declaraciones \ttt{if-elif-else} para revisar todos los casos posibles.

\pythonfile{codigo/8-funciones/sobrecarga_1.py}
\out{codigo/8-funciones/sobrecarga_1.out}

El siguiente ejemplo muestra una función que calcula el área de una figura geométrica. Si sólo se le entrega 1 argumento asume que es un cuadrado y si se le entregan 2 asume que es un rectángulo.

\pythonfile{codigo/8-funciones/sobrecarga_2.py}
\out{codigo/8-funciones/sobrecarga_2.out}

%TODO: mostrar valores por defecto

\section{Anotaciones de tipos}

Una anotación de tipos es, como su nombre lo dice, una notación opcional que especifica el tipo de los parámetros de una función y su tipo de retorno.

\pythonfile{codigo/8-funciones/anotaciones_1.py}
\out{codigo/8-funciones/anotaciones_1.out}

En el ejemplo de arriba, se muestra que mensaje es un parámetro de tipo string y que la función \ttt{duplicar()} retorna un string.\smallskip

Esto le permite al programador saber qué tipos de datos se le deben entregar una función y que tipos de datos esperar cuando esta función retorne.\smallskip

Las anotaciones de tipos son ignoradas completamente por el intérprete de Python. No restringen el tipo de los parámetros o del retorno de una función, pero son muy útiles al momento de documentar.

\pythonfile{codigo/8-funciones/anotaciones_2.py}
\out{codigo/8-funciones/anotaciones_2.out}

Aunque el intérprete de Python los ignore, existen algunos IDEs y programas que pueden analizar código que contiene anotaciones de tipos y alertar sobre problemas potenciales.

\clearpage\chapter{Módulos y la biblioteca estándar}

\section{Módulos}

Los módulos son pedazos de código que otras personas han escrito para cumplir tareas comunes tales como generar números aleatorios, realizar operaciones matemáticas, etc.\smallskip

La manera básica de utilizar un módulo es agregar una declaración \ttt{import} en la parte superior del código, y luego usar su nombre para acceder a las funciones y variables dentro del módulo.

\pythonfile{codigo/9-modulos/ejemplo_modulos.py}

Este ejemplo importa el módulo \ttt{random} y usa su función \ttt{randint()} para generar 5 números aleatorios en el rango del \ttt{1} al \ttt{6}.\smallskip

Hay otra clase de \ttt{import} que puede ser utilizada si sólo se necesitan ciertas funciones de un módulo.

\pythonfile{codigo/9-modulos/import_1.py}
\out{codigo/9-modulos/import_1.out}

Para importar más de un elemento, se debe hacer una lista separada por comas.

\pythonfile{codigo/9-modulos/import_2.py}

También se pueden importar todos los objetos de un módulo usando un *. Esto generalmente no se recomienda, ya que confunde las variables del código original con las del módulo externo.

\pythonfile{codigo/9-modulos/import_todo.py}
\out{codigo/9-modulos/import_todo.out}

Las variables que provienen de módulos también se pueden reasignar, aunque en la mayoría de casos no hay razón para hacerlo.

\pythonfile{codigo/9-modulos/import_3.py}
\out{codigo/9-modulos/import_3.out}

Para ver una lista de módulos disponibles, se puede usar la función \ttt{help()} de la siguiente forma:

\pythonfile{codigo/9-modulos/lista_modulos.py}

\section{Error de importación}

Importar un módulo que no existe dará un \ttt{ModuleNotFoundError}, o uno que no está disponible dará un \ttt{ImportError}.

\pythonfile{codigo/9-modulos/error_import.py}
\out{codigo/9-modulos/error_import.out}

\section{Alias}

Se puede importar un módulo u objeto bajo un nombre distinto utilizando la palabra clave \ttt{as} y entregándole un alias. Esto se usa principalmente cuando un módulo u objeto tiene un nombre largo o confuso.

\pythonfile{codigo/9-modulos/alias_1.py}
\out{codigo/9-modulos/alias_1.out}

También se puede usar un alias con más de un objeto.

\pythonfile{codigo/9-modulos/alias_2.py}
\out{codigo/9-modulos/alias_2.out}

Después de darle un alias a un objeto, su nombre original no funcionará.

\pythonfile{codigo/9-modulos/error_alias.py}
\out{codigo/9-modulos/error_alias.out}

La notación mixta, importando algunos objetos con alias y otros sin alias, está permitida.

\pythonfile{codigo/9-modulos/alias_3.py}
\out{codigo/9-modulos/alias_3.out}

Otra opción posible es importar un módulo con un nombre distinto.

\pythonfile{codigo/9-modulos/alias_4.py}
\out{codigo/9-modulos/alias_4.out}

\section{La biblioteca estándar}

Hay 3 tipos principales de módulos en Python: aquellos que escribes tú mismo, aquellos que se instalan de fuentes externas y aquellos que vienen preinstalados con Python.\smallskip

El último tipo se denomina la biblioteca estándar, y contiene muchos módulos útiles. Algunos de estos módulos son:

\textfile{codigo/9-modulos/biblioteca_estandar.txt}

La extensa biblioteca estándar de Python es una de sus principales fortalezas como lenguaje. Se puede encontrar más información sobre los módulos de la biblioteca estándar en \link{https://docs.python.org/3/library/index.html}{la documentación}.\smallskip

Algunos de los módulos en la biblioteca estándar están escritos en Python y otros en C. La mayoría están disponibles en todas las plataformas, pero algunos son específicos de Windows o Unix.\smallskip

La razón por la que algunos módulos fueron escritos en \link{https://es.wikipedia.org/wiki/C_(lenguaje_de_programaci\%C3\%B3n)}{C} fue porque necesitaban realizar acciones de más bajo nivel que lo posible usando únicamente Python.

\section{Módulos externos y pip}

Muchos módulos de Python creados por terceros son almacenados en el índice de paquetes Python (Python Package Index, PyPI). Se puede ver el repositorio en su \link{https://pypi.org}{sitio web oficial}.\smallskip

La mejor manera de instalar estos es utilizando un programa llamado \ttt{pip}. Este viene instalado por defecto con las distribuciones modernas de Python.\smallskip

Para instalar una biblioteca, se debe buscar su nombre, ir a la línea de comandos y escribir \ttt{pip install nombre}.

\textfile{codigo/9-modulos/pip_1.txt}

Es importante recordar que los comandos de \ttt{pip} se deben introducir en la línea de comandos, no en el interpretador de Python.\smallskip

Se puede ingresar el comando \ttt{pip help} para ver información sobre otros comandos que se pueden usar con este gestor de paquetes.

\textfile{codigo/9-modulos/pip_2.txt}

Utilizar \ttt{pip} es la forma estándar de instalar bibliotecas en la mayoría de sistemas operativos, pero algunas bibliotecas tienen binarios predefinidos para Windows. Estos son archivos ejecutables regulares que permiten instalar bibliotecas con una interfaz gráfica de la misma manera que se instalan otros programas.

\section{Obtener ayuda}

Cuando se trabaja con Python, como cualquier otro lenguaje, es muy común olvidar los métodos que se pueden usar con determinados tipos de datos.\smallskip

La función \ttt{dir()} es una función integrada en Python que permite ver los métodos que puede usar un determinado objeto.

\pythonfile{codigo/9-modulos/ayuda_1.py}
\out{codigo/9-modulos/ayuda_1.out}

Esto permite saber con facilidad qué métodos se pueden usar con la variable que se está usando.

\pythonfile{codigo/9-modulos/ayuda_2.py}
\out{codigo/9-modulos/ayuda_2.out}

Los métodos rodeados por \ttt{\_\_} son métodos mágicos, se verán en el capítulo de programación orientada a objetos.\smallskip

El resultado obtenido al usar \ttt{dir()} se puede combinar con el método \ttt{help()} para obtener más detalles sobre un método en específico.

\pythonfile{codigo/9-modulos/ayuda_3.py}
\out{codigo/9-modulos/ayuda_3.out}

El método \ttt{help()} también se puede usar para obtener ayuda detallada sobre módulos importados.

\pythonfile{codigo/9-modulos/ayuda_4.py}
\out{codigo/9-modulos/ayuda_4.out}

Por defecto, el método \ttt{help()} sólo mostrará el texto que alcance en el alto de la ventana del terminal. Al pulsar la tecla \ttt{Intro}, se mostrará la línea que viene después de \ttt{-{}- Más  -{}-}. Como siempre, se puede pulsar \ttt{Ctrl+C} para salir.\smallskip

También se puede usar el método \ttt{dir()} en módulos, para ver los métodos dentro de ellos.

\pythonfile{codigo/9-modulos/ayuda_5.py}
\out{codigo/9-modulos/ayuda_5.out}

\clearpage\chapter{El módulo math}

\section{El módulo math}

\section{Constantes matemáticas}

\section{Infinito}

Para representar un número infinitamente pequeño o grande, se puede usar el método \ttt{float()} y entregarle el string \ttt{\qq inf \qq} como argumento.

\pythonfile{codigo/10-math/infinito.py}
\out{codigo/10-math/infinito.out}

\section{Funciones matemáticas predefinidas}

%TODO: mover sum(), investigar si existe avg() y parecidos

Python viene con algunas funciones matemáticas sencillas, que se pueden usar sin necesidad de importar el módulo \ttt{math}.

Para obtener la distancia entre un número y el \ttt{0} (su valor absulto), puede usarse la función \ttt{abs()}.

\pythonfile{codigo/10-math/abs.py}
\out{codigo/10-math/abs.out}

Para redondear un número a un determinado número de decimales, puede usarse la función \ttt{round()}.

\pythonfile{codigo/10-math/round.py}
\out{codigo/10-math/round.out}

%TODO: este capítulo

\section{Funciones trigonométricas}

\clearpage\chapter{El módulo random}

\clearpage\chapter{Excepciones}

\section{Excepciones}

Se han mencionado excepciones en los capítulos anteriores. Ocurren cuando algo sale, mal, debido a código incorrecto o entradas incorrectas. Cuando ocurre una excepción, el programa se detiene inmediatamente.\smallskip

Por ejemplo, al intentar dividir por \ttt{0}, se produce un \ttt{ZeroDivisionError}.

\pythonfile{codigo/12-excepciones/excepcion.py}
\out{codigo/12-excepciones/excepcion.out}

Otras excepciones comunes son:

\begin{itemize}
  \item \ttt{ImportError}: Cuando falla una importación.
  
  \item \ttt{IndexError}: Cuando se intenta indexar una lista con un número fuera de rango.
  
  \item \ttt{NameError}: Cuando una variable desconocida es utilizada.
  
  \item \ttt{SyntaxError}: Cuando el código no puede ser analizado correctamente.
  
  \item \ttt{TypeError}: Cuando una función es llamada con un valor de tipo inapropiado.
  
  \item \ttt{ValueError}: Cuando una función es llamada con un valor del tipo correcto, pero con un valor incorrecto.
  
\end{itemize}

Una lista más detallada de excepciones se puede encontrar en la \link{https://docs.python.org/3/library/exceptions.html}{documentación oficial}.

Las bibliotecas creadas por terceros a menudo definen sus propias excepciones.

\section{Declaración try-except}

Para manejar excepciones y ejecutar código cuando ocurre una excepción, se puede usar una sentencia \ttt{try-except}. El bloque \ttt{try} contiene código que puede lanzar una excepción. Si ocurre una excepción, el código en el bloque \ttt{try} deja de ser ejecutado y el código en el bloque \ttt{except} se ejecuta. Si no ocurre ningún error, el código en el bloque \ttt{except} no se ejecutará.

\pythonfile{codigo/12-excepciones/try_except_1.py}
\inp{codigo/12-excepciones/try_except_1.inp_1}
\out{codigo/12-excepciones/try_except_1.out_1}
\inp{codigo/12-excepciones/try_except_1.inp_2}
\out{codigo/12-excepciones/try_except_1.out_2}

Una sentencia \ttt{try} puede tener varios bloques \ttt{except} para manejar diferentes excepciones. Varias excepciones pueden ser colocadas dentro de un mismo bloque \ttt{except} utilizando paréntesis.

\pythonfile{codigo/12-excepciones/try_except_2.py}
\inp{codigo/12-excepciones/try_except_2.inp}
\out{codigo/12-excepciones/try_except_2.out}

Una sentencia \ttt{except} sin ninguna excepción especificada atrapa todos los errores. Estos deben usarse con moderación ya que pueden atrapar errores inesperados y esconder errores de programación.

\pythonfile{codigo/12-excepciones/except.py}
\out{codigo/12-excepciones/except.out}

Si una sentencia \ttt{except} vacía viene acompañada de otros \ttt{except}, esta debe ir al final, para evitar atrapar errores esperados.

\pythonfile{codigo/12-excepciones/try_except_3.py}

\section{Declaración finally}

Para asegurar que algún código se ejecute sin importar cuál error ocurra, se puede usar la palabra clave \ttt{finally}. La sentencia \ttt{finally} se coloca en el fondo de una sentencia \ttt{try-except}. El código dentro de la sentencia \ttt{finally} siempre se ejecuta después del código del bloque \ttt{try} y de cualquier bloque \ttt{except} que se ejecute.

\pythonfile{codigo/12-excepciones/finally_1.py}
\out{codigo/12-excepciones/finally_1.out}

El código dentro del bloque \ttt{finally} se ejecutará incluso si una excepción sin atrapar ocurre en alguno de los bloques que lo preceden.

\pythonfile{codigo/12-excepciones/finally_2.py}
\out{codigo/12-excepciones/finally_2.out}

Si ocurre una excepción sin atrapar, la excepción se muestra después de lo que contenía la expresión \ttt{finally}.

%TODO: explicar por qué ocurre

\section{Levantar excepciones}

Se puede usar la sentencia \ttt{raise} para levantar excepciones. Se necesita especificar el tipo de la excepción levantada.

\pythonfile{codigo/12-excepciones/raise_1.py}
\out{codigo/12-excepciones/raise_1.out}

Las excepciones pueden ser levantadas con argumentos que den detalles sobre ellas.

\pythonfile{codigo/12-excepciones/raise_2.py}
\out{codigo/12-excepciones/raise_2.out}

\pythonfile{codigo/12-excepciones/raise_3.py}
\inp{codigo/12-excepciones/raise_3.inp}
\out{codigo/12-excepciones/raise_3.out}

En los bloques \ttt{except}, la sentencia \ttt{raise} puede ser utilizada sin argumentos para volver a levantar cualquier excepción que haya ocurrido.

\pythonfile{codigo/12-excepciones/raise_4.py}
\out{codigo/12-excepciones/raise_4.out}

Usar \ttt{raise} fuera de los contextos mencionados anteriormente levantará un \ttt{RuntimeError}.

\pythonfile{codigo/12-excepciones/error_raise.py}
\out{codigo/12-excepciones/error_raise.out}

\section{Aserciones}

Una aserción es una comprobación de validez, la cual prueba una expresión. La expresión es probada, y si el resultado es falso, usa excepción \ttt{AssertionError} es levantada.\smallskip

Las aserciones son llevadas a cabo a través de la declaración \ttt{assert}.

\pythonfile{codigo/12-excepciones/assert_1.py}
\out{codigo/12-excepciones/assert_1.out}

Los programadores a menudo colocan aserciones al principio de una función para asegurarse de que la entrada sea válida, y luego de llamar una función para revisar la validez de la salida.\smallskip

La declaración \ttt{assert} puede recibir un segundo argumento el cual es pasado a la excepción \ttt{AssertionError} levantada si la aserción falla.

\pythonfile{codigo/12-excepciones/assert_2.py}
\out{codigo/12-excepciones/assert_2.out}

Las excepciones \ttt{AssertionError} pueden ser atrapadas y manejadas como cualquier otra excepción utilizando la sentencia \ttt{try-except}, pero si no son manejadas, terminarán la ejecución el programa, como cualquier otra excepción.\smallskip

En general, se recomienda usar aserciones para atrapar tus propios errores y excepciones para atrapar los errores que los usuarios u otras personas podrían cometer.\smallskip

Las declaraciones \ttt{assert} no pueden ir sin un predicado.

\pythonfile{codigo/12-excepciones/error_assert.py}
\out{codigo/12-excepciones/error_assert.out}

\section{Validación de entrada}

El ingreso de datos en cualquier programa es algo que se debe validar para que el programa trabaje correctamente.\smallskip

Supongamos que se quiere que el usuario ingrese un número. Esto se haría usando la función \ttt{input()} para tomar entrada y la función \ttt{int()} para convertirla a un número entero.\smallskip

Un problema que puede ocurrir es si el usuario ingresa una letra o símbolo que no puede ser convertido a un número entero.

\pythonfile{codigo/12-excepciones/validacion_1.py}
\inp{codigo/12-excepciones/validacion_1.inp_1}
\out{codigo/12-excepciones/validacion_1.out_1}
\inp{codigo/12-excepciones/validacion_1.inp_2}
\out{codigo/12-excepciones/validacion_1.out_2}

Para manejar este error, se debería usar un \ttt{try-except} para atrapar la excepción \ttt{ValueError}.

\pythonfile{codigo/12-excepciones/validacion_2.py}
\inp{codigo/12-excepciones/validacion_2.inp}
\out{codigo/12-excepciones/validacion_2.out}

Esto soluciona el problema que ocurre por la excepción \ttt{ValueError} no capturada, pero hace falta el uso de un bucle para pedir la entrada nuevamente en caso de que no sea válida.

\pythonfile{codigo/12-excepciones/validacion_3.py}
\inp{codigo/12-excepciones/validacion_3.inp}
\out{codigo/12-excepciones/validacion_3.out}

Supongamos que el programa necesita pedir la edad del usuario en vez de un número cualquiera. Eso significa que los valores negativos no son válidos, lo cual puede solucionarse usando una declaración \ttt{if-else}.

\pythonfile{codigo/12-excepciones/validacion_4.py}
\inp{codigo/12-excepciones/validacion_4.inp}
\out{codigo/12-excepciones/validacion_4.out}

Esa es la estructura general para cualquier validación de entrada. Primero se atrapan las excepciones y después se evalúan los casos particulares no excepcionales que no se consideran válidos.\smallskip

Lo más importante de la validación de entrada es asumir que el usuario puede hacer cualquier acción en cualquier momento. El programador debe anteponerse a todos los casos posibles y manejarlos para evitar cualquier error que pueda ocurrir durante el tiempo de ejecución.

%TODO: excepciones personalizadas

\clearpage\chapter{Pruebas unitarias}

\section{Pruebas unitarias}

%TODO: este capítulo

\section{Precedencia de operadores completa}

En los capítulos anteriores, se mostró parte de la precedencia de operadores (por ejemplo, PEMDAS). En Python, todos los operadores tienen un orden específico en el que funcionan, incluyendo a muchos que no se han visto todavía.\smallskip

El orden definitivo es el siguiente:

\begin{enumerate}
  \item \ttt{()}: paréntesis para agrupar operaciones
  
  \item \ttt{f(argumentos)}: llamadas a funciones
  
  \item \ttt{x[indice:indice]}: cortes (slicing)
  
  \item \ttt{x[indice]}: subscripción
  
  \item \ttt{x.atributo}: referencias a atributos
  
  \item \ttt{**}: exponenciación
  
  \item \ttt{~x}: NOT en bitwise
  
  \item \ttt{+x}, \ttt{-x}: signo positivo y negativo
  
  \item \ttt{*}, \ttt{/}, \ttt{//}, \ttt{\%}: multiplicación, división, cociente y resto
  
  \item \ttt{+, -}: adición y substracción (diferencia)
  
  \item \ttt{<<, >>}: cambios en bitwise
  
  \item \ttt{\&}: AND en bitwise (unión)
  
  \item \ttt{\^}: XOR en bitwise (diferencia simétrica)
  
  \item \ttt{|}: OR en bitwise (intersección)
  
  \item \ttt{in}, \ttt{not in}, \ttt{is}, \ttt{is not} , \ttt{<}, \ttt{<=}, \ttt{>}, \ttt{>=}, \ttt{<>}, \ttt{!=}, \ttt{==}: comparaciones, membresía e identidad
  
  \item \ttt{not x}: NOT booleano
  
  \item \ttt{and}: AND booleano
  
  \item \ttt{or}: OR booleano
  
  \item \ttt{lambda}: expresiones lambda

\end{enumerate}

Todas las operaciones que estén en un mismo nivel se realizarán de izquierda a derecha.\smallskip

Lo ideal sería utilizar paréntesis para evitar cualquier confusión que pueda causar el uso de muchos operadores, pero también es importante conocer este orden para los casos en los que no se utilizaron.

\clearpage\chapter{Archivos}

%TODO: revisión de \ttt{} lista hasta aquí

\section{Abrir archivos}

Python se puede usar para leer y escribir los contenidos de archivos. Los archivos de texto son los más fáciles de manipular.\smallskip

Antes de que un archivo pueda ser editado, debe ser abierto con la función open().

\pythonfile{codigo/14-archivos/open.py}

El argumento de la función open es la ruta del archivo. Esta ruta puede ser \link{https://www.discoduroderoer.es/rutas-relativas-y-absolutas/}{relativa} (desde el directorio de trabajo) o \link{https://www.discoduroderoer.es/rutas-relativas-y-absolutas/}{absoluta}.\smallskip

Si se necesita, se puede hacer \link{https://stackoverflow.com/questions/7165749/open-file-in-a-relative-location-in-python}{un procedimiento un poco más largo} para abrir un archivo relativamente desde el directorio donde se encuentra el archivo \ttt{.py}, sin importar cual sea el directorio de trabajo o sistema operativo.

\pythonfile{codigo/14-archivos/open_seguro.py}

En este caso, \ttt{ruta\_relativa} es lo único que debe cambiarse para abrir un archivo distinto dentro del mismo directorio.

\section{Modos de apertura}

Se puede especificar el modo utilizado para abrir un archivo al pasar un segundo argumento a la función open().

Los modos de apertura son:

\begin{itemize}
  \item \ttt{''r''}: Significa modo de lectura, el cual es el modo predeterminado.
  
  \pythonfile{codigo/14-archivos/modo_r.py}

  \item \ttt{''w''}: Significa modo de escritura, el cual sirve para reescribir los contenidos de un archivo. Abrir un archivo en este modo inmediatamente borra todos sus contenidos.
  
  \pythonfile{codigo/14-archivos/modo_w.py}

  \item \ttt{''x''}: Significa modo de creación exclusiva, se usa para crear un fichero y escribir sobre él.
  
  \pythonfile{codigo/14-archivos/modo_x.py}

  Entrega un error FileExistsError si el archivo ya existe y no está vacío.

  \pythonfile{codigo/14-archivos/error_modo_x.py}
  \Ainicial{codigo/14-archivos/error_modo_x.txt_i}
  \out{codigo/14-archivos/error_modo_x.out}

  \item \ttt{''a''}: significa modo de anexo, para agregar nuevo contenido al final de un archivo.

  \pythonfile{codigo/14-archivos/modo_a.py}

\end{itemize}

Además de los modos de apertura, también existen los modos en los que se muestra la información:

\begin{itemize}
  \item \ttt{''t''}: significa abrir el archivo en modo texto (predeterminado). No es necesario escribirlo.
  
  \item \ttt{''b''}: significa abrir el archivo en modo binario, que es utilizado para archivos que no son de texto (tales como archivos de imágenes o sonido). Se debe combinar con alguno de los modos anteriores.

  \pythonfile{codigo/14-archivos/modo_b.py}

\end{itemize}

\section{Extensión de modos de apertura}

Se puede añadir el signo \ttt{''+''} a cualquiera de los modos de arriba para darles acceso adicional a archivos.\smallskip

La siguiente tabla muestra el funcionamiento de cada modo:

% tabla 1

\makebox[\textwidth][c]{
  \begin{tabular}{ |c|c|c|c|c|c|c|c|c| }
    \hline
    & r & r+ & w & w+ & x & x+ & a & a+ \\
    \hline
    Lee el archivo & \si & \si & \no & \si & \no & \si & \no & \si \\
    \hline
    Escribe en el archivo & \no & \si & \si & \si & \si & \si & \si & \si \\
    \hline
    Crea el archivo si no existe & \no & \no & \si & \si & \si & \si & \si & \si \\
    \hline
    Borra todos los contenidos del archivo & \no & \no & \si & \si & \noo & \noo & \no & \no \\
    \hline
    Posición del cursor & \inicio & \inicio & \inicio & \inicio & \inicio & \inicio & \final & \final \\
    \hline
  \end{tabular}
}

\textcolor{Crimson}{*}: Levanta una excepción FileExistsError si el archivo ya tiene contenido.

\section{Cierre de archivos}

Una vez que un archivo haya sido abierto y utilizado, es un buen hábito cerrarlo. Esto se logra con el método \ttt{close()} de un objeto archivo.

\pythonfile{codigo/14-archivos/close.py}

A nivel de sistemas operativos, cada proceso tiene un límite en la cantidad de archivos que puede abrir simultáneamente. Si un programa se ejecuta por mucho tiempo y podría abrir muchos archivos, se debe tener cuidado.

\section{Lectura de archivos}

Los contenidos de un archivo que ha sido abierto en modo texto pueden ser leídos utilizando el método \ttt{read()}.

\pythonfile{codigo/14-archivos/read_1.py}
\Ainicial{codigo/14-archivos/read_1.txt_i}
\out{codigo/14-archivos/read_1.out}

Para leer sólo una determinada parte de un archivo, se puede proveer un número como argumento a la función \ttt{read()}. Esto determina el número de bytes que deberían ser leídos.\smallskip

Se pueden hacer más llamadas a \ttt{read()} en el mismo objeto archivo para leer más de él byte por byte. Si no se le pasan argumentos, o si el argumento es negativo, \ttt{read()} devuelve el resto del archivo.

\pythonfile{codigo/14-archivos/read_2.py}
\Ainicial{codigo/14-archivos/read_2.txt_i}
\out{codigo/14-archivos/read_2.out}

El ejemplo de arriba primero mostrará los bytes del 1 al 16, después del 17 al 24, del 25 al 28, y del 29 al último byte.\smallskip

Luego de que todos los contenidos de un archivo hayan sido leídos, cualquier intento de leer más de ese archivo devolverá una cadena vacía $''$$''$ porque se está intentando leer desde el final del archivo.

\pythonfile{codigo/14-archivos/read_3.py}
\Ainicial{codigo/14-archivos/read_3.txt_i}
\out{codigo/14-archivos/read_3.out}

Usando el método seek(), se puede mover el \doble{cursor} (puntero) al principio del archivo.

\pythonfile{codigo/14-archivos/seek_1.py}
\Ainicial{codigo/14-archivos/seek_1.txt_i}
\out{codigo/14-archivos/seek_1.out}

Alternativamente, se le puede decir a \ttt{seek()} que se mueva a otra posición.

\pythonfile{codigo/14-archivos/seek_2.py}
\Ainicial{codigo/14-archivos/seek_2.txt_i}
\out{codigo/14-archivos/seek_2.out}

El método \ttt{tell()} entrega la posición actual del puntero.

\pythonfile{codigo/14-archivos/tell.py}
\Ainicial{codigo/14-archivos/tell.txt_i}
\out{codigo/14-archivos/tell.out}

Para obtener cada línea de un archivo, se puede usar la función \ttt{readlines()} para devolver una lista donde cada elemento es una línea del archivo.

\pythonfile{codigo/14-archivos/readlines.py}
\Ainicial{codigo/14-archivos/readlines.txt_i}
\out{codigo/14-archivos/readlines.out}

Esto también se puede hacer usando un bucle for.

\pythonfile{codigo/14-archivos/for_readlines.py}
\Ainicial{codigo/14-archivos/for_readlines.txt_i}
\out{codigo/14-archivos/for_readlines.out}

\section{Escritura de archivos}

Para escribir sobre archivos se utiliza el método write(), el cual escribe una cadena en un archivo.

\pythonfile{codigo/14-archivos/write_1.py}
\Ainicial{codigo/14-archivos/write_1.txt_i}
\Afinal{codigo/14-archivos/write_1.txt_f}

Cuando un archivo es abierto en modo de escritura, el contenido existente del archivo es borrado.

\pythonfile{codigo/14-archivos/write_2.py}
\Ainicial{codigo/14-archivos/write_2.txt_i}
\Afinal{codigo/14-archivos/write_2.txt_f}

Para evitar que esto ocurra, se puede usar el modo anexo \doble{a}.

\pythonfile{codigo/14-archivos/write_3.py}
\Ainicial{codigo/14-archivos/write_3.txt_i}
\Afinal{codigo/14-archivos/write_3.txt_f}

El método \ttt{write()} devuelve el número de bytes escritos en un archivo, si su llamada es exitosa.

\pythonfile{codigo/14-archivos/write_4.py}
\Ainicial{codigo/14-archivos/write_4.txt_i}
\Afinal{codigo/14-archivos/write_4.txt_f}
\out{codigo/14-archivos/write_4.out}

Para escribir algo que no sea un string, necesita ser convertido primero a un string.

\pythonfile{codigo/14-archivos/write_5.py}
\Ainicial{codigo/14-archivos/write_5.txt_i}
\Afinal{codigo/14-archivos/write_5.txt_f}

\section{Declaración with}

Es buena práctica evitar gastar recursos asegurándose de que los archivos sean siempre cerrados después de utilizarlos. Una forma de hacer esto es utilizando \ttt{try-finally}.

\pythonfile{codigo/14-archivos/close_seguro.py}

Esto asegura que el archivo sea siempre cerrado incluso si ocurre un error.
Sin embargo, existe una forma más cómoda de hacer esto usando declaraciones with.\smallskip

Una forma alternativa de trabajar con archivos es utilizando declaraciones with. Esto crea una variable temporal (a menudo llamada f), la cual solo es accesible en el bloque indentado de la declaración with.

\pythonfile{codigo/14-archivos/with_1.py}

El archivo se cierra automáticamente al final de la declaración with, incluso si ocurren excepciones dentro de ella.\smallskip

Comparado con la forma tradicional de trabajar con archivos (open-close), usar \ttt{with} tiene el inconveniente de que los archivos tienen que volverse a abrir cada vez que se quiera trabajar con ellos.\smallskip

Así, una forma más segura de trabajar con archivos puede tener la siguiente estructura:

\pythonfile{codigo/14-archivos/with_2.py}

\clearpage\chapter{Módulos time y datetime}

\clearpage\chapter{Estructuras de datos}

\section{Estructuras de datos}

%TODO: esta sección

\section{Diccionarios}

Los diccionarios son estructuras de datos utilizadas para mapear claves arbitrarias a valores. Pueden ser indexados de la misma manera que las listas, utilizando corchetes que contengan claves.

\pythonfile{codigo/16-estructuras/diccionarios_1.py}
\out{codigo/16-estructuras/diccionarios_1.out}

Cada elemento de un diccionario es representado por un par clave:valor (key:value). Los elementos dentro de diccionarios no están ordenados, lo que significa que no pueden ser indexados por índices, sólo por claves.\smallskip

Un diccionario puede almacenar como valor cualquier tipo de datos. Se pueden usar saltos de línea para definirlos de forma más ordenada.

\pythonfile{codigo/16-estructuras/diccionarios_2.py}
\out{codigo/16-estructuras/diccionarios_2.out}

\section{Listas como diccionarios}

Las listas pueden ser consideradas como diccionarios con claves de números enteros dentro de un cierto rango.

\pythonfile{codigo/16-estructuras/listas_como_diccionarios.py}
\out{codigo/16-estructuras/listas_como_diccionarios.out}

\section{Diccionario vacío}

Un diccionario vacío es definido como \ttt{\{\}}.

\pythonfile{codigo/16-estructuras/diccionario_vacio.py}

\section{Excepciones en diccionarios}

Tratar de indexar una clave que no es parte de un diccionario retorna un \ttt{KeyError}.

\pythonfile{codigo/16-estructuras/error_diccionario.py}
\out{codigo/16-estructuras/error_diccionario.out}

Sólo objetos inmutables pueden ser utilizados como claves de diccionario. Los objetos inmutables son aquellos que no pueden ser cambiados. Algunos objetos mutables son listas, conjuntos y diccionarios. Tratar de utilizar un objeto mutable como clave de diccionario ocasiona un \ttt{TypeError}.

\pythonfile{codigo/16-estructuras/error_clave_mutable.py}
\out{codigo/16-estructuras/error_clave_mutable.out}

\section{Indexación de diccionarios}

Al igual que las listas, las claves de un diccionario pueden ser asignadas a distintos valores. Sin embargo, a diferencia de las listas, se le puede asignar un valor a nuevas claves, no sólo a las que ya existen.

\pythonfile{codigo/16-estructuras/indexacion_diccionarios.py}
\out{codigo/16-estructuras/indexacion_diccionarios.out}

\section{Uso de in y not en diccionarios}

Para determinar si una clave está en un diccionario, se puede usar los operadores in y not in, al igual que en listas.

\pythonfile{codigo/16-estructuras/in_not_diccionarios.py}
\out{codigo/16-estructuras/in_not_diccionarios.out}

Nótese que retorna \ttt{False} al buscar \ttt{"tres"}. Esto ocurre porque \ttt{"tres"} es un valor, no una clave.

\section{Función get()}

Un método útil de diccionarios es \ttt{get()}. Hace lo mismo que indexar, pero si una clave no es encontrada en el diccionario entonces devuelve otro valor especificado (\simple{None} por defecto).

\pythonfile{codigo/16-estructuras/get_1.py}
\out{codigo/16-estructuras/get_1.out}

En este caso es importante recordar que 1 y True son la misma clave. Entonces, el diccionario \doble{pares} sólo tiene 3 elementos (la clave True tendrá como valor False, su último valor).

\pythonfile{codigo/16-estructuras/get_2.py}
\out{codigo/16-estructuras/get_2.out}

%TODO: esta sección

\section{Función keys()}

\section{Tuplas}

Las tuplas son estructuras de datos muy parecidas a las listas, excepto que son inmutables (no pueden ser cambiadas). También se crean utilizando paréntesis en vez de corchetes.

\pythonfile{codigo/16-estructuras/tupla_1.py}

Las tuplas son más rápidas que las listas, pero no pueden ser modificadas.

\section{Indexación de Tuplas}

Se puede acceder a los valores de una tupla utilizando su índice. Funciona de la misma forma que con listas.

\pythonfile{codigo/16-estructuras/tupla_2.py}
\out{codigo/16-estructuras/tupla_2.out}

Los datos dentro de una tupla están ordenados, empezando desde el índice \ttt{0}.

\section{Excepciones en tuplas}

Tratar de reasignar un valor a una tupla ocasiona un \ttt{TypeError}.

\pythonfile{codigo/16-estructuras/error_tupla.py}
\out{codigo/16-estructuras/error_tupla.out}

\section{Anidación de tuplas}

Al igual que las listas y diccionarios, las tuplas pueden ser anidadas entre sí.
Las tuplas son inmutables, pero el contenido de elementos mutables dentro de ellas puede ser cambiado.

\pythonfile{codigo/16-estructuras/anidacion_tuplas.py}
\out{codigo/16-estructuras/anidacion_tuplas.out}

\section{Tupla vacía}

Una tupla vacía se crea utilizando un par de paréntesis vacíos.

\pythonfile{codigo/16-estructuras/tupla_vacia.py}

\section{Manejo de variables con tuplas}

Las tuplas pueden \doble{empaquetarse} o \doble{desempaquetarse}, lo que puede ser útil al momento de crear variables.

\pythonfile{codigo/16-estructuras/tupla_3.py}
\out{codigo/16-estructuras/tupla_3.out}

Las tuplas pueden ser creadas sin paréntesis, simplemente separando los valores por comas.

\pythonfile{codigo/16-estructuras/sin_parentesis.py}
\out{codigo/16-estructuras/sin_parentesis.out}

Se pueden usar tuplas para intercambiar los valores de 2 variables.

\pythonfile{codigo/16-estructuras/truco_tuplas.py}
\out{codigo/16-estructuras/truco_tuplas.out}

\section{Conjuntos}

Los conjuntos son estructuras de datos parecidas a las listas o a los diccionarios. Son creandos utilizando llaves o la función set(). Comparten algunas de las funcionalidades de las listas, como el uso de in para revisar si contienen o no un elemento en particular.

\pythonfile{codigo/16-estructuras/conjuntos.py}
\out{codigo/16-estructuras/conjuntos.out}

No están ordenados, lo cual significa que no pueden ser indexados. No pueden tener elementos duplicados.

\pythonfile{codigo/16-estructuras/sin_duplicados.py}
\out{codigo/16-estructuras/sin_duplicados.out}

Usos básicos de conjuntos incluyen pruebas de membresía y la eliminación de entradas duplicadas.

\section{Conjunto vacío}

Para crear un conjunto vacío, se debe utilizar \ttt{set()}, ya que \ttt{\{\}} crea un diccionario vacío.

\pythonfile{codigo/16-estructuras/conjunto_vacio.py}

\section{Métodos de conjuntos}

Los conjuntos difieren de las listas de varias formas, pero comparten varias operaciones de listas como \ttt{len()}.

\pythonfile{codigo/16-estructuras/len_conjuntos.py}
\out{codigo/16-estructuras/len_conjuntos.out}

Debido a la forma en que son almacenados, es más rápido revisar si un elemento es parte de un conjunto que si es parte de una lista.\smallskip

En lugar de utilizar \ttt{append()} para agregarle algo al conjunto, se utiliza \ttt{add()}. El método \ttt{remove()} elimina un elemento específico de un conjunto.

\pythonfile{codigo/16-estructuras/add_y_remove.py}
\out{codigo/16-estructuras/add_y_remove.out}

El método \ttt{pop()} elimina un elemento arbitrario. Esto significa que debido a la forma en la Python implementa conjuntos, no hay garantía de que los elementos se retornarán en el mismo orden que en el que se añadieron.\smallskip

Generalmente, elimina el primer elemento, pero esto no se puede garantizar.

\pythonfile{codigo/16-estructuras/pop_conjuntos.py}

\section{Operaciones con conjuntos}

Los conjuntos pueden ser combinados utilizando operaciones matemáticas.\smallskip

El operador de unión \ttt{|} combina dos conjuntos para formar uno nuevo que contiene los elementos de cualquiera de los dos.

\pythonfile{codigo/16-estructuras/union.py}
\out{codigo/16-estructuras/union.out}

El operador de intersección \ttt{\&} obtiene sólo los elementos que están en ambos.

\pythonfile{codigo/16-estructuras/interseccion.py}
\out{codigo/16-estructuras/interseccion.out}

El operador de diferencia \ttt{-} obtiene los elementos que están en el primer conjunto, pero no en el segundo.

\pythonfile{codigo/16-estructuras/diferencia.py}
\out{codigo/16-estructuras/diferencia.out}

El operador de diferencia simétrica \ttt{\^} obtiene los elementos que están en cualquiera de los conjuntos, pero no en ambos.

\pythonfile{codigo/16-estructuras/diferencia_simetrica.py}
\out{codigo/16-estructuras/diferencia_simetrica.out}

\section{Resumen sobre estructuras de datos}

Como se ha visto en este capítulo, Python tiene soporte de las siguientes estructuras de datos: listas, diccionarios, tuplas y conjuntos.\smallskip

¿Cúando utilizar diccionarios?

\begin{itemize}
  \item Cuando se necesita utilizar asociaciones lógicas entre pares clave:valor.
  
  \item Cuando se necesita buscar datos rápidamente, en base a claves personalizadas.
  
  \item Cuando los datos son constantemente modificados.
  
\end{itemize}

¿Cúando utilizar listas?

\begin{itemize}
  \item Cuando se tiene un grupo de datos que no necesita acceso aleatorio (deben estar ordenados).
  
  \item Cuando se necesita una recolección simple e iterable que es modificada frecuentemente.
  
\end{itemize}

¿Cúando utilizar conjuntos?

\begin{itemize}
  \item Cuando se necesita que los elementos sean únicos.
\end{itemize}

¿Cúando utilizar tuplas?

\begin{itemize}
  \item Cuando se necesita almacenar datos que no pueden ser cambiados.
\end{itemize}

En muchas ocasiones, una tupla es utilizada junto con un diccionario. Por ejemplo, una tupla puede representar una clave, porque es inmutable.\smallskip

La siguiente tabla muestra las propiedades de cada estructura de datos.

% tabla 2

\makebox[\textwidth][c]{
  \begin{tabular}{ |c|c|c|c|c| }
    \hline
    & Lista & Diccionario & Tupla & Conjunto \\
    \hline
    Mutable & \si & \si & \no & \si \\
    \hline
    Indexado & \indices & \claves & \indices & \no \\
    \hline
    Secuencial & \si & \no & \si & \no \\
    \hline
    Elementos únicos & \no & \no & \no & \si \\
    \hline
    Notación & [ ] & \{ \} & ( ) & \{ \} \\
    \hline
  \end{tabular}
}

Existen estructuras de datos más complejas, pero no se verán todavía.

\clearpage\chapter{Iterables}

%TODO: iterables https://pythonbasics.org/iterable/

\section{Cortes de lista}

Los cortes de lista ofrecen una manera más avanzada de obtener valores de una lista. Los cortes de lista básicos involucran indexar una lista con dos enteros separados por dos puntos. Esto devuelve una lista nueva que contiene todos los valores de la lista vieja entre los índices.

\pythonfile{codigo/17-iterables/cortes_1.py}
\out{codigo/17-iterables/cortes_1.out}

Como los argumentos de range, el primer índice provisto en un corte es incluido en el resultado, pero el segundo no.\smallskip

Si el primer número en un corte es omitido, se toma el principio de la lista. Si el segundo número es omitido, se toma el final de la lista.

\pythonfile{codigo/17-iterables/cortes_2.py}
\out{codigo/17-iterables/cortes_2.out}

Los cortes de lista también pueden tener un tercer número, representando el incremento, para incluir valores alternativos en el corte.

\pythonfile{codigo/17-iterables/cortes_3.py}
\out{codigo/17-iterables/cortes_3.out}

Los valores negativos pueden ser utilizados en un corte de lista. Cuando los valores negativos son utilizados para el primer y el segundo valor del corte, estos cuentan desde el final de la lista.

\pythonfile{codigo/17-iterables/cortes_4.py}
\out{codigo/17-iterables/cortes_4.out}

El tamaño de paso también puede ser negativo, lo que permite usarlos para invertir listas sin usar el método \ttt{reverse()}.

\pythonfile{codigo/17-iterables/cortes_reverse.py}
\out{codigo/17-iterables/cortes_reverse.out}

Es importante recordar que si el tamaño de paso es negativo, el primer número debe indicar un índice mayor que el segundo.\smallskip

Se pueden usar cortes para copiar listas, aunque no suele ser la forma más clara de hacerlo.

\pythonfile{codigo/17-iterables/copy_cortes.py}
\out{codigo/17-iterables/copy_cortes.out}

\section{Cortes de tuplas}

Los cortes también pueden ser realizados en tuplas. Su funcionamiento es el mismo que con listas.

\pythonfile{codigo/17-iterables/cortes_en_tuplas.py}
\out{codigo/17-iterables/cortes_en_tuplas.out}

Esto es válido porque si bien las tuplas son inmutables, los cortes no realizan ningún cambio sobre los objetos con los que trabajan. Sólo consultan información de cierta manera.

\section{Subcadenas}

En Python pueden usarse cortes para obtener trozos de una cadena. Esto es lo que otros lenguajes de programación realizan usando el método \ttt{substring()}. Funciona de la misma forma que con listas y tuplas.

\pythonfile{codigo/17-iterables/substring_1.py}
\out{codigo/17-iterables/substring_1.out}

%TODO: más

\section{Listas por compresión}

Las listas por compresión son una forma útil de crear rápidamente listas cuyo contenido obedece una regla sencilla.

\pythonfile{codigo/17-iterables/compresion_1.py}
\out{codigo/17-iterables/compresion_1.out}

%TODO: enlace a constructores de conjuntos
Las listas por compresión son inspiradas por la notación de constructores de conjuntos en las matemáticas.\smallskip

Una lista por compresión también puede contener una sentencia \ttt{if} para aplicar una condición en los valores de la lista.

\pythonfile{codigo/17-iterables/compresion_2.py}
\out{codigo/17-iterables/compresion_2.out}

Intentar crear una lista de rango demasiado extenso resultará en un \ttt{MemoryError}. Es posible que la operación tarde unos minutos en llegar a esta excepción, o que el PC se quede sin memoria antes de que llegue a aparecer.

\pythonfile{codigo/17-iterables/compresion_3.py}

Se debe recordar que se puede interrumpir la ejecución del programa en cualquier momento enviando un \ttt{KeyboardInterrupt}, al pulsar \ttt{Ctrl+C}.\smallskip

Este problema de memoria es resuelto con generadores, los cuales se verán más tarde.

\section{Formateo de cadenas}

La forma más básica de combinar cadenas y objetos que no son cadenas es convirtiendo dichos objetos a cadenas y concatenando las cadenas.\smallskip

El formateo de cadenas ofrece una manera más potente de incorporar objetos que no son cadenas a las cadenas. El formateo de cadenas utiliza el método \ttt{format()} de una cadena para sustituir los argumentos de esta.\smallskip

Una forma de hacerlo es usando índices.

\pythonfile{codigo/17-iterables/formateo_1.py}
\out{codigo/17-iterables/formateo_1.out}

Cada argumento de la función de formateo es colocada en la cadena de la posición correspondiente, que es determinada usando llaves \ttt{\{\}}.\smallskip

Los índices entre llaves \ttt{\{\}} pueden repetirse cuantas veces se quiera.

\pythonfile{codigo/17-iterables/formateo_2.py}
\out{codigo/17-iterables/formateo_2.out}

Si se omite un índice, habrá algún argumento de \ttt{format()} que no se usará.

\pythonfile{codigo/17-iterables/formateo_3.py}
\out{codigo/17-iterables/formateo_3.out}

No es necesario escribir los índices dentro de las llaves {}, pero esto no permite que se repitan o que se entreguen como argumentos en otro orden.

\pythonfile{codigo/17-iterables/formateo_4.py}
\out{codigo/17-iterables/formateo_4.out}

El formateo de cadenas también puede hacerse con argumentos con nombre.

\pythonfile{codigo/17-iterables/formateo_5.py}
\out{codigo/17-iterables/formateo_5.out}

\section{Funciones de cadenas}

Python contiene muchas funciones integradas y métodos útiles que sirven para cumplir tareas comunes. Algunos métodos que se pueden usar con strings son:

\begin{itemize}
  \item join(): Combina una lista de cadenas con otra cadena como separador.
  
  \pythonfile{codigo/17-iterables/join.py}
  \out{codigo/17-iterables/join.out}

  \item replace(): Reemplaza una subcadena de una cadena por otra cadena.

  \pythonfile{codigo/17-iterables/replace.py}
  \out{codigo/17-iterables/replace.out}

  \item startswith(): Determina si hay una subcadena al principio de una cadena.

  \pythonfile{codigo/17-iterables/startswith.py}
  \out{codigo/17-iterables/startswith.out}

  \item endswith(): Determina si hay una subcadena al final de una cadena.
  
  \pythonfile{codigo/17-iterables/endswith.py}
  \out{codigo/17-iterables/endswith.out}

  \item A diferencia de otros lenguajes de programación, Python no tiene el método contains(), para ver si una subcadena pertenece a un string.\smallskip
  
  Usar el operador in tiene el mismo efecto que tendría dicha función.

  %TODO: contains (if x in string)

  \item upper(): Cambia una cadena a mayúsculas.
  
  \pythonfile{codigo/17-iterables/upper.py}
  \out{codigo/17-iterables/upper.out}

  \item lower(): Cambia una cadena a minúsculas.
  
  \pythonfile{codigo/17-iterables/lower.py}
  \out{codigo/17-iterables/lower.out}

  \item capitalize(): Cambia una cadena para que la primera letra sea mayúscula y el resto minúsculas.

  \pythonfile{codigo/17-iterables/capitalize.py}
  \out{codigo/17-iterables/capitalize.out}
  
  \item title(): Cambia una cadena para que todas las palabras empiecen con mayúscula.
  
  \pythonfile{codigo/17-iterables/title.py}
  \out{codigo/17-iterables/title.out}

\end{itemize}

Al método \ttt{split()} te visto anteriormentambién se le puede entregar un string separador. La lista será formada con los elementos entre cada aparición de ese string.

\pythonfile{codigo/6-listas/split_avanzado.py}
%TODO: out y rehacer el ejemplo

\section{Funciones all() y any()}

Las funciones \ttt{all()} y \ttt{any()} son utilizados con frecuencia como sentencias condicionales. Estos toman una lista como un argumento y devuelven True si todos o algunos (respectivamente) de sus argumentos son evaluados como True (o, de lo contrario, False).

\pythonfile{codigo/17-iterables/all.py}
\out{codigo/17-iterables/all.out}

\pythonfile{codigo/17-iterables/any.py}
\out{codigo/17-iterables/any.out}

\section{Función enumerate()}

La función \ttt{enumerate()} se usa para iterar a través de los valores e índices de una lista, simultáneamente.

\pythonfile{codigo/17-iterables/enumerate_1.py}
\out{codigo/17-iterables/enumerate_1.out}

También se puede especificar el índice desde el que comienza.

\pythonfile{codigo/17-iterables/enumerate_2.py}
\out{codigo/17-iterables/enumerate_2.out}

\clearpage\chapter{Programación funcional}

\section{Paradigma de programación funcional}

La programación funcional es un estilo de programación que, como dice su nombre, gira en torno a funciones.\smallskip

Una parte clave de la programación funcional son las funciones de orden superior. Similar al uso de funciones como objetos, las funciones de orden superior reciben otras funciones como argumentos, o las devuelven como resultado.

\pythonfile{codigo/18-funcional/ejemplo_funcional.py}
\out{codigo/18-funcional/ejemplo_funcional.out}

La función \ttt{repetir2veces()} mostrada en el ejemplo recibe otra función como su argumento y llama 2 veces dentro de su cuerpo.\smallskip

Entender los conceptos de programación funcional requiere un conocimiento básico del concepto algebraico llamado \link{https://www.mathsisfun.com/sets/functions-composition.html}{\doble{composición de funciones}}.

\section{Funciones puras}

La programación funcional busca utilizar funciones puras. Las funciones puras no tienen efectos secundarios y devuelven un valor que depende únicamente de sus argumentos.\smallskip

Así son las funciones en las matemáticas. Por ejemplo, la función cos(x) siempre devolverá un mismo resultado para el mismo valor de x.

Ejemplo de función pura:

\pythonfile{codigo/18-funcional/pura.py}

Ejemplo de función impura:

\pythonfile{codigo/18-funcional/impura.py}

Dicho de otra forma, una función pura cumple lo siguiente:

\begin{itemize}
  \item Depende sólo de sus argumentos y de variables locales creadas dentro de ella.
  
  \item Siempre retorna el mismo resultado para los mismos argumentos.

  \item Se puede ejecutar en cualquier parte del programa sin causar efectos secundarios de ningún tipo.
  
  \item No altera ningún elemento fuera de ella.
  
  \item Puede usarse en otros programas y entrega los mismos resultados.
  
\end{itemize}

Utilizar funciones puras tiene sus ventajas y desventajas.

Las funciones puras son:

\begin{itemize}
  \item Más fáciles de analizar y probar.
  
  \item Más eficientes. Una vez que la función haya sido evaluada para una entrada, el resultado puede ser almacenado y referenciado para la próxima vez que la función con esa entrada sea necesaria, reduciendo el número de veces que la función es llamada. Esto se denomina memorización.
  
  \item Más fáciles de ejecutar en paralelo.
  
\end{itemize}

Desventajas principales:

\begin{itemize}
  \item Complican en su mayor parte la normalmente sencilla tarea de Entrada/Salida, ya que requiere de efectos secundarios inherentemente.
  
  \item En algunas situaciones, pueden ser más difíciles de escribir.
  
\end{itemize}

\section{Lambdas}

Crear una función normalmente (utilizando def) le asigna una variable automáticamente.\smallskip

Esto es distinto a la creación de otros objetos, tales como cadenas y enteros, que pueden ser creados en el camino, sin la necesidad de asignarles una variable.\smallskip

Lo mismo es posible con las funciones, dado que sean creadas utilizando la sintaxis lambda. Funciones creadas de esta forma son conocidas como anónimas.
Este enfoque es más comúnmente utilizado cuando se pasa una función sencilla como argumento de otra función.\smallskip

La sintaxis que se muestra a continuación consiste de la palabra reservada lambda seguida de una lista de argumentos, dos puntos, y una expresión a evaluar y devolver.

\pythonfile{codigo/18-funcional/lambda_1.py}
\out{codigo/18-funcional/lambda_1.out}

Las funciones lambda reciben su nombre del \link{https://es.wikipedia.org/wiki/C\%C3\%A1lculo_lambda}{cálculo lambda}, el cual es un modelo computacional inventado por Alonzo Church.\smallskip

Las funciones lambda no son tan potentes como las funciones con nombre. Sólo pueden hacer cosas que requieren de una sola expresión, normalmente equivalente a una sola línea de código.

\pythonfile{codigo/18-funcional/lambda_2.py}
\out{codigo/18-funcional/lambda_2.out}

Las funciones lambda pueden ser asignadas a variables y ser utilizadas como funciones regulares.

\pythonfile{codigo/18-funcional/lambda_3.py}
\out{codigo/18-funcional/lambda_3.out}

Sin embargo, rara vez existe una buena razón para hacer esto. Normalmente es mejor definir una función con def.

\section{Función map()}

La función \ttt{map()} es una función de orden superior muy útil que opera sobre listas (u objetos similares llamados iterables).\smallskip

Esta función recibe una función y un iterable como argumentos y devuelve un nuevo iterable con la función aplicada a cada argumento.

\pythonfile{codigo/18-funcional/map_1.py}
\out{codigo/18-funcional/map_1.out}

El mismo resultado se puede obtener con mayor facilidad utilizando la sintaxis lambda.

\pythonfile{codigo/18-funcional/map_2.py}
\out{codigo/18-funcional/map_2.out}

Los objetos del tipo mapa son iterables, por lo que se debe usar \ttt{list()} para convertir el resultado en una lista y poder verlo.

\section{Función filter()}

La función \ttt{filter()} es otra función de orden supero que se puede usar sobre iterables.\smallskip

Esta función filtra un iterable eliminando elementos que no coincidan con el predicado (una función que devuelve un booleano).

\pythonfile{codigo/18-funcional/filter.py}
\out{codigo/18-funcional/filter.out}

Al igual que \ttt{map()}, el resultado tiene que ser convertido explícitamente a una lista si se quiere imprimir.

\section{Generadores}

Los generadores son un tipo de iterable, como las listas o las tuplas.\smallskip

A diferencia de las listas, no permiten indexar con índices arbitrarios, pero pueden aún ser iterados con bucles for.\smallskip

Pueden ser creados utilizando funciones y la sentencia yield.

\pythonfile{codigo/18-funcional/generador_1.py}
\out{codigo/18-funcional/generador_1.out}

Nótese que si en el ejemplo anterior no se hubiera especificado la condición de salida, hubiera seguido contando infinitamente en los negativos y tendría que detenerse pulsando \ttt{Ctrl+C}.\smallskip

La sentencia yield es utilizada para definir un generador, reemplazando el retorno de una función para proveer un resultado a su llamador sin destruir las variables locales.\smallskip

Debido al hecho que yield produce un elemento a la vez, los generadores no tienen las restricciones de memoria de las listas. De hecho, ¡pueden ser infinitos!

\pythonfile{codigo/18-funcional/generador_2.py}
\out{codigo/18-funcional/generador_2.out}

En resumen, los generadores permiten declarar una función que se comporta como un iterador. En otras palabras, que puede utilizarse en un bucle for.\smallskip

Un ejemplo de uso de generadores es para generar números primos.
%TODO: más ejemplos

\pythonfile{codigo/18-funcional/generador_de_primos.py}
\out{codigo/18-funcional/generador_de_primos.out}

Los generadores finitos pueden ser convertidos en listas al pasarlos como argumentos de la función list().

\pythonfile{codigo/18-funcional/generador_a_lista.py}
\out{codigo/18-funcional/generador_a_lista.out}

Utilizar generadores resulta en un mejor rendimiento, el cual es el resultado de una generación ociosa de valores (a medida que se vayan necesitando), lo cual se traduce en un uso reducido de memoria. Es más, no necesitamos esperar hasta que todos los elementos sean generados antes de empezar a utilizarlos.

\section{Decoradores}

Los decoradores ofrecen una forma de modificar funciones utilizando otras funciones. Esto es ideal cuando se necesita extender la funcionalidad de funciones que no se quieren modificar.

\pythonfile{codigo/18-funcional/decorador_1.py}
\out{codigo/18-funcional/decorador_1.out}

En este caso, el uso la función \ttt{envolver()} se define dentro de \ttt{decor()} para permitir que \ttt{decor()} retorne una función, que es el objetivo principal de un decorador. La función \ttt{texto\_decorado()} es una versión decorada de la función \ttt{imprimir\_texto()}.\smallskip

De hecho, si se escribiera un decorador útil, podría reemplazarse \ttt{imprimir\_texto()} por su versión decorada.

%TODO: explicar que print() es un salto de línea antes
\pythonfile{codigo/18-funcional/decorador_2.py}
\out{codigo/18-funcional/decorador_2.out}

En el ejemplo anterior, se decora la función \ttt{imprimir\_texto()} reemplazando la variable que contiene la función por una versión envuelta.

\pythonfile{codigo/18-funcional/decorador_3.py}

Este patrón puede utilizarse en cualquier momento, para envolver cualquier función.\smallskip

Python ofrece apoyo para envolver una función en un decorador anteponiendo la definición de la función con el nombre de un decorador y el símbolo \ttt{\@}, lo cual tendrá el mismo resultado que el código de arriba.

\pythonfile{codigo/18-funcional/decorador_4.py}

Una sola función puede tener varios decoradores y cada decorador puede repetirse más de una vez.

\pythonfile{codigo/18-funcional/decorador_5.py}
\out{codigo/18-funcional/decorador_5.out}

Los decoradores pueden ser usados para muchos otros propósitos además de \doble{decorar}.

\pythonfile{codigo/18-funcional/decorador_entrada.py}

\pythonfile{codigo/18-funcional/decorador_tiempo.py}

\section{Recursión}

La recursión es un concepto muy importante en la programación funcional.\smallskip

Lo fundamental de la recursión es la autorreferencia, funciones que se llaman a sí mismas. Se utiliza para resolver problemas que pueden ser divididos en subproblemas más sencillos del mismo tipo.\smallskip

Un ejemplo clásico de una función que es implementada recursiva es la función factorial.

\pythonfile{codigo/18-funcional/factorial.py}
\out{codigo/18-funcional/factorial.out}

El caso base \ttt{n == 0} actúa como condición de salida de la recursión, porque no involucra más llamadas a la función.\smallskip

Las funciones recursivas pueden ser infinitas, al igual que los bucles while. Estas ocurren cuando se olvida implementar algún caso base.\smallskip

Abajo se muestra una versión incorrecta de la función factorial. No tiene caso base, así que se ejecuta hasta que al interpretador se le acabe la memoria o se cuelgue.

\pythonfile{codigo/18-funcional/factorial_malo.py}
\out{codigo/18-funcional/factorial_malo.out}

La recursión también puede ser indirecta. Una función puede llamar a una segunda, que a su vez llama a la primera, que llama a la segunda, y así sucesivamente. Esto puede ocurrir con cualquier cantidad de funciones.

\pythonfile{codigo/18-funcional/par_o_impar.py}
\out{codigo/18-funcional/par_o_impar.out}

Otro ejemplo clásico es la serie de Fibonacci.

\pythonfile{codigo/18-funcional/fibonacci.py}
\out{codigo/18-funcional/fibonacci.out}

\section{Iteración vs. Recursión}

%TODO: más ejemplos de generadores aquí

\section{Generadores recursivos}

% yield from

\clearpage\chapter{El módulo itertools}

\section{El módulo itertools}

El módulo itertools es una biblioteca estándar que contiene varias funciones que son útiles en la programación funcional.

\pythonfile{codigo/19-itertools/itertools.py}

\section{Iteradores infinitos}

Uno de los tipos de función que produce son iteradores infinitos.\smallskip

La función \ttt{count()} cuenta infinitamente a partir de un valor.

\pythonfile{codigo/19-itertools/count_1.py}
\out{codigo/19-itertools/count_1.out}

Se le puede entregar un segundo parámetro a \ttt{count()}, el cual representa el tamaño de paso. Si no se le entrega el segundo parámetro, el tamaño de paso por defecto es 1.

\pythonfile{codigo/19-itertools/count_2.py}
\out{codigo/19-itertools/count_2.out}

Si el segundo parámetro es negativo, cuenta hacia atrás.

\pythonfile{codigo/19-itertools/count_3.py}
\out{codigo/19-itertools/count_3.out}

La función\ttt{cycle()} itera infinitamente a través de un iterable (como una lista o cadena).

\pythonfile{codigo/19-itertools/cycle_1.py}
\out{codigo/19-itertools/cycle_1.out}

\pythonfile{codigo/19-itertools/cycle_2.py}
\out{codigo/19-itertools/cycle_2.out}

La función \ttt{repeat()} repite un objeto, ya sea infinitamente o un número específico de veces.

\pythonfile{codigo/19-itertools/repeat_1.py}
\out{codigo/19-itertools/repeat_1.out}

Puede usarse para crear listas que tengan un objeto repetido.

\pythonfile{codigo/19-itertools/repeat_2.py}
\out{codigo/19-itertools/repeat_2.out}

Para repetir infinitamente, se le debe entregar sólo el objeto como parámetro.

\pythonfile{codigo/19-itertools/repeat_3.py}
\out{codigo/19-itertools/repeat_3.out}

\section{Operaciones sobre iterables}

Hay muchas funciones en itertools que operan sobre iterables, de una forma similar a \ttt{map()} o \ttt{filter()}.\smallskip

La función \ttt{accumulate()} devuelve un total actualizado de los valores dentro de un iterable.

\pythonfile{codigo/19-itertools/accumulate.py}
\out{codigo/19-itertools/accumulate.out}

La función \ttt{takewhile()} toma elementos de un iterable mientras una función predicado permanece verdadera.

\pythonfile{codigo/19-itertools/takewhile_1.py}
\out{codigo/19-itertools/takewhile_1.out}

La diferencia entre \ttt{takewhile()} y \ttt{filter()} es que \ttt{takewhile()} deja de tomar elementos cuando llega al primer elemento que no cumple la condición de la función.

\pythonfile{codigo/19-itertools/takewhile_2.py}
\out{codigo/19-itertools/takewhile_2.out}

La función \ttt{chain()} combina varios iterables en uno solo más largo.

\pythonfile{codigo/19-itertools/chain.py}
\out{codigo/19-itertools/chain.out}

\section{Funciones de combinatoria}

También hay numerosas funciones combinatorias en itertools, tales como \ttt{product()} y \ttt{permutations()}. Estas son usadas cuando se quiere cumplir tareas con todas las combinaciones posibles de algunos elementos.\smallskip

La función \ttt{product()} retorna el producto entre 2 iterables.

\pythonfile{codigo/19-itertools/product.py}
\out{codigo/19-itertools/product.out}

La función \ttt{permutations()} retorna las todas permutaciones posibles entre los elementos de un iterable.

\pythonfile{codigo/19-itertools/permutations_1.py}
\out{codigo/19-itertools/permutations_1.out}

\pythonfile{codigo/19-itertools/permutations_2.py}
\out{codigo/19-itertools/permutations_2.out}

Se le puede entregar un segundo argumento, el cual representa el número de elementos que cada permutación debe tener.

\pythonfile{codigo/19-itertools/permutations_3.py}
\out{codigo/19-itertools/permutations_3.out}

El método \ttt{combinations()} funciona de forma similar a \ttt{permutations()}, pero muestra las combinaciones en vez de permutaciones.

\pythonfile{codigo/19-itertools/combinations.py}
\out{codigo/19-itertools/combinations.out}

La diferencia es que en las combinaciones no importa el orden y se unen todos los resultados que tienen los mismos elementos pero en orden distinto.

\clearpage\chapter{Programación orientada a objetos}

%TODO: mejorar la redacción en todo el capítulo

\section{Programación orientada a objetos}

Anteriormente se vieron 2 paradigmas de programación: imperativa (utilizando declaraciones, bucles y funciones como subrutinas) y funcional (utilizando funciones puras, funciones de orden superior y recursión).\smallskip

Otro paradigma muy popular es la programación orientada a objetos (POO). Los objetos son creados utilizando clases, las cuales son en realidad el eje central de la POO.

\section{Objetos}

Un objeto es una abstracción de un objeto en la vida real. Este objeto tiene características que lo describen (atributos) y comportamientos o acciones que puede realizar (métodos).\smallskip

Ejemplo de un objeto:

\begin{itemize}
  \item Persona:

  \item Posibles atributos: su nombre, su edad, su sexo, su altura, su peso, sus colores de pelo o piel, su país de residencia, etc.
  
  \item Posibles métodos: hablar, comer, dormir, caminar, correr, trabajar, pensar, etc.

\end{itemize}

Otra forma de verlo es que los objetos son sustantivos, los atributos son adjetivos y los métodos son verbos.\smallskip

En términos más técnicos, un objeto es una instancia de una clase, y una clase es un molde usado para construir objetos. Con una misma clase, se pueden construir muchos objetos que comparten las mismas características, pero que tienen sus propios valores únicos para cada objeto.

\section{Clases}

%TODO: revisar todos los ejemplos

Una clase describe lo que el objeto será, pero es independiente del objeto mismo. En otras palabras, una clase puede ser descrita como los planos, la descripción o definición de un objeto. Una misma clase puede ser utilizada como plano para crear varios objetos diferentes.\smallskip

Los objetos son una instancia de una clase, es decir, las clases dicen qué tiene un objeto, pero no indican los valores específicos de lo que tiene. Solo describen, no detallan.\smallskip

Las clases son creadas utilizando la palabra clave \ttt{class} y un bloque indentado que contiene los métodos de una clase (los cuales son funciones) y puede contener sus atributos (que son variables) propias de la clase y sus objetos.\smallskip

Para instanciar una clase y construir un objeto, sólo basta con llamar su método constructor usando el nombre de la clase y entregarle sus atributos como argumentos.

\pythonfile{codigo/20-objetos/clases_1.py}

El código de arriba define una clase llamada Gato, la cual tiene el atributo color. Luego, la clase es utilizada para crear 2 objetos independientes de esa clase, los cuales son el Gato Félix y el Gato Tigre.\smallskip

Las partes de una clase se verán en más detalle a continuación.

\section{Constructor}

El método \_\_init\_\_ es el más importante de una clase, conocido como constructor. Es llamado cuando una instancia de una clase (objeto) es creada, utilizando el nombre de la clase como función.\smallskip

Si el método \ttt{\_\_init\_\_()} va vacío, no es necesario escribirlo.

\pythonfile{codigo/20-objetos/sin_constructor.py}
\out{codigo/20-objetos/sin_constructor.out}

\pythonfile{codigo/20-objetos/con_constructor.py}
\out{codigo/20-objetos/con_constructor.out}

Ambos ejemplos mostrados arriba tienen el mismo efecto. Pero claramente, no ocurre nada interesante al crear objetos tan simples.\smallskip

Veamos un ejemplo más complejo.

\pythonfile{codigo/20-objetos/clases_2.py}

Todos los constructores de una clase deben tener \ttt{self} como su primer parámetro. No se necesita entregar \ttt{self} al momento de instanciar.\smallskip

Dentro de la definición de un método, self se refiere a la misma instancia que está llamando al método.

\section{Atributos y self}

Las instancias de una clase tienen atributos, los cuales son datos asociados a ellas, que definen sus características. En este ejemplo, las instancias de Persona tienen los atributos nombre y edad.

\pythonfile{codigo/20-objetos/atributos_1.py}

En el constructor \ttt{\_\_init\_\_()}, se le dan los parámetros self, nombre y edad. El parámetro self se refiere a la instancia, mientras que nombre y edad son los atributos de la persona.\smallskip

El uso de self es para distinguir los atributos que se le entregan al constructor de los que tendrá la instancia. En este caso serán el mismo, pero se les puede dar valores por defecto.

\pythonfile{codigo/20-objetos/atributos_2.py}

Después, un objeto se construye dándole valores a sus atributos. En este ejemplo, tiene sentido pensar que nombre es un string y edad es un número.

\pythonfile{codigo/20-objetos/atributos_3.py}

Los atributos pueden ser accedidos al poner un punto seguido del nombre del atributo luego del nombre de una instancia.

\pythonfile{codigo/20-objetos/atributos_4.py}
\out{codigo/20-objetos/atributos_4.out}

El valor que tiene un atributo también puede ser cambiado durante la ejecución del programa.

\pythonfile{codigo/20-objetos/atributos_5.py}
\out{codigo/20-objetos/atributos_5.out}

%TODO: enlace aquí
En Python, no existen los setters y getters que se ven en otros lenguajes con orientación a objetos.

\section{Métodos}

Las clases pueden tener otros métodos definidos para agregarles funcionalidad. Todos los métodos deben tener self como su primer parámetro.\smallskip

Estos métodos son accedidos utilizando la misma sintaxis de punto que los atributos.

\pythonfile{codigo/20-objetos/metodos.py}
\out{codigo/20-objetos/metodos.out}

\section{Atributos de clase}

Las clases pueden tener atributos de clase también, creados al asignar variables dentro del cuerpo de una clase. Estos pueden ser accedidos desde instancias de una clase o desde la clase misma.

\pythonfile{codigo/20-objetos/atributos_de_clase_1.py}
\out{codigo/20-objetos/atributos_de_clase_1.out}

Los atributos de clase son compartidos por todas las instancias de una clase. Realizar algún cambio a un atributo de la clase también hará ese cambio en las instancias de esa clase.

\pythonfile{codigo/20-objetos/atributos_de_clase_2.py}
\out{codigo/20-objetos/atributos_de_clase_2.out}

\section{Excepciones de clases}

Tratar de acceder a un atributo de una instancia que no está definida generará un \ttt{AttributeError}. Esto también aplica cuando se llama un método no definido.

\pythonfile{codigo/20-objetos/error_atributo.py}
\out{codigo/20-objetos/error_atributo.out}

\pythonfile{codigo/20-objetos/error_metodo.py}
\out{codigo/20-objetos/error_metodo.out}

\section{Herencia}

La herencia brinda una forma de compartir funcionalidades entre clases.\smallskip

Por ejemplo, las clases Perro, Gato, Conejo, etc. tienen algo en común. Aunque presenten algunas diferencias, también tienen muchas características en común. Este parecido puede ser expresado haciendo que todos hereden de una superclase Animal, que contiene las funcionalidades compartidas.\smallskip

Para heredar de una clase desde otra, se coloca el nombre de la superclase entre paréntesis luego del nombre de la clase.

\pythonfile{codigo/20-objetos/herencia_1.py}
\out{codigo/20-objetos/herencia_1.out}

Una clase que hereda de otra clase se llama subclase. Una clase de la cual se hereda se llama superclase. Los métodos y atributos de la superclase son heredados por sus subclases\smallskip

Si una clase hereda de otra con los mismos atributos o métodos, los sobreescribe.

\pythonfile{codigo/20-objetos/herencia_2.py}
\out{codigo/20-objetos/herencia_2.out}

La herencia también puede ser indirecta. Una clase hereda de otra, y esa clase puede a su vez heredar de una tercera clase.

\pythonfile{codigo/20-objetos/herencia_3.py}
\out{codigo/20-objetos/herencia_3.out}

Sin embargo, no es posible la herencia circular.

\pythonfile{codigo/20-objetos/herencia_circular.py}
\out{codigo/20-objetos/herencia_circular.out}

Intentar hacer herencia circular de otras formas sólo terminará sobreescribiendo clases, haciendo que siempre haya una superclase de las otras 2.

\section{Función super()}

La función \ttt{super()} es una útil función relacionada con la herencia que hace referencia a la clase padre. Puede ser utilizada para encontrar un método con un determinado nombre en la superclase del objeto.

\pythonfile{codigo/20-objetos/super_1.py}
\out{codigo/20-objetos/super_1.out}

También se puede usar para llamar al constructor de la superclase.

\pythonfile{codigo/20-objetos/super_2.py}
\out{codigo/20-objetos/super_2.out}

Otra forma de verlo es que cuando una subclase no tiene un método, lo buscará en su superclase antes de lanzar una excepción diciendo que no existe. Si no lo encuentra en su superclase, lo buscará en la superclase de su superclase, y así sucesivamente.\smallskip

El método usado será el primero que encuentre al realizar esa búsqueda.

\section{Métodos mágicos}

Los métodos mágicos son métodos especiales que tienen doble guión bajo al principio y al final de sus nombres. Son también conocidos en inglés como dunders (de double underscores).\smallskip

El constructor \ttt{\_\_init\_\_()} es un método mágico, pero existen muchos más. Son utilizados para crear funcionalidades que no pueden ser representadas en un método regular.

\section{Sobrecarga de operadores aritméticos}

Un uso común de métodos mágicos es la sobrecarga de operadores. Esto significa definir operadores para clases personalizadas que permiten que operadores tales como \ttt{+} y \ttt{*} sean utilizados en ellas.\smallskip

El método mágico \ttt{\_\_add\_\_()} permite sobrecargar el operador \ttt{+}, lo cual permite darle un comportamiento personalizado.

\pythonfile{codigo/20-objetos/sobrecarga_operadores_1.py}
\out{codigo/20-objetos/sobrecarga_operadores_1.out}

El método \ttt{\_\_add\_\_()} suma los atributos correspondientes de los objetos y devuelve un nuevo objeto que contiene el resultado. Una vez definido, se pueden sumar dos objetos de una clase entre sí.\smallskip

Otra forma de verlo es que el intérprete de Python siempre interpretará el operador + como el método \ttt{\_\_add\_\_()} de su clase.\smallskip

Los métodos mágicos para operadores comunes son:

\textfile{codigo/20-objetos/aritmeticos.txt}

Y después el intérprete de Python interpreta los operadores así:

\pythonfile{codigo/20-objetos/sobrecarga_operadores_2.py}
\out{codigo/20-objetos/sobrecarga_operadores_2.out}

A continuación, se muestra un ejemplo de implementación del método \ttt{\_\_truediv\_\_}.

\pythonfile{codigo/20-objetos/truediv.py}
\out{codigo/20-objetos/truediv.out}

La sobrecarga de operadores no necesita que los métodos mágicos nuevos cumplan una función parecida a la original. Pueden ser cualquier cosa.\smallskip

\section{Métodos mágicos reversos}

Un caso particular ocurre cuando \doble{x} e \doble{y} son de tipos distintos y \doble{x} no tiene definido un método mágico, por ejemplo \ttt{\_\_add\_\_()}. En este caso, Python intentará calcular la operación al revés, la cual en este caso será \ttt{y + x}. Para realizar esta operación llamará al método reverso \ttt{\_\_radd\_\_()} de \ttt{y}.\smallskip

Hay métodos r equivalentes para todos los operadores mencionados anteriormente.

\textfile{codigo/20-objetos/sobrecarga_reversos.txt}

Y un ejemplo de implementación de métodos reversos:

\pythonfile{codigo/20-objetos/radd.py}
\out{codigo/20-objetos/radd.out}

\section{Sobrecarga de operadores de comparación}

Python también ofrece métodos mágicos para comparaciones.

\textfile{codigo/20-objetos/comparadores.txt}

Si \_\_ne\_\_ no está implementado, devuelve el opuesto de \_\_eq\_\_. No hay ninguna otra relación entre los otros operadores.

\pythonfile{codigo/20-objetos/gt.py}
\out{codigo/20-objetos/gt.out}

\section{Métodos mágicos de contenedores}

Hay varios métodos mágicos para hacer que las clases actúen como contenedores.

\textfile{codigo/20-objetos/contenedores.txt}

A continuación, se muestra un ejemplo rebuscado pero creativo, el cual consiste en crear una clase de lista poco confiable o imprecisa.

\pythonfile{codigo/20-objetos/lista_imprecisa.py}

%TODO: Buscar fuente para métodos mágicos en la documentación

\section{Ciclo de vida de un objeto}

El ciclo de vida de un objeto está conformado por su creación, manipulación y destrucción.\smallskip

La primera etapa del ciclo de vida de un objeto es la definición de la clase a la cual pertenece.\smallskip

La siguiente etapa es la instanciación de un objeto, cuando el método \_\_init\_\_ es llamado. La memoria es asignada para almacenar la instancia. Justo antes de que esto ocurra, el método \_\_new\_\_ de la clase es llamado, para asignar la memoria necesaria. Este es normalmente redefinido sólo en casos especiales.\smallskip

Luego de que ocurra lo anterior el objeto estará listo para ser utilizado.\smallskip

Otro código puede interactuar con el objeto, llamando sus métodos o accediendo a sus atributos. Eventualmente, terminará de ser utilizado y podrá ser destruido.\smallskip

Cuando un objeto es destruido, la memoria asignada se libera y puede ser utilizada para otros propósitos.\smallskip

La destrucción de un objeto ocurre cuando su contador de referencias llega a cero. La cuenta de referencias es el número de variables y otros elementos que se refieren al objeto.\smallskip

Si nada se está refiriendo al objeto (tiene una cuenta de referencias de 0) nada puede interactuar con este, así que puede ser eliminado con seguridad.
En algunas situaciones, dos (o más) objetos pueden solo referirse entre ellos, y por lo tanto pueden ser eliminados también.\smallskip

La sentencia del reduce la cuenta de referencias de un objeto por 1, y a menudo conlleva a su eliminación. El método mágico de la sentencia del es \_\_del\_\_.\smallskip

El proceso de eliminación de objetos cuando ya no son necesarios se denomina recolección de basura (garbage collection).\smallskip

En resumen, el contador de referencias de un objeto se incrementa cuando se le es asignado un nuevo nombre o es colocado en un contenedor (una lista, tupla o diccionario). La cuenta de referencias de un objeto se disminuye cuando es eliminado con del, su referencia es reasignada, o su referencia sale fuera del alcance. Cuando la cuenta de referencias de un objeto llega a 0, Python lo elimina automáticamente.

\pythonfile{codigo/20-objetos/contador_referencias.py}

Lenguajes de bajo nivel como C no tienen esta clase de manejo de memoria automático. Se debe realizar manualmente en ellos.

\section{Ocultamiento de información}

Un componente clave de la programación orientada a objetos es el encapsulamiento, que involucra empaquetar las variables y funciones relacionadas en un único objeto fácil de usar, una instancia de una clase.\smallskip

Un concepto asociado es el de ocultamiento de información, el cual dicta que los detalles de implementación de una clase deben estar ocultos y que sean presentados a aquellos que quieran utilizar la clase en una interfaz estándar limpia. En otros lenguajes de programación, esto se logra normalmente utilizando métodos y atributos privados, los cuales bloquean el acceso externo a ciertos métodos y atributos en una clase.\smallskip

La filosofía de Python es ligeramente diferente. A menudo se dice \doble{todos somos adultos consistentes aquí}, que significa que no deberías poner restricciones arbitrarias al acceso de las partes de una clase. Por ende, no hay formas de imponer que un método o atributo sea estrictamente privado.\smallskip

Sin embargo, hay maneras de desalentar a la gente de acceder a las partes de una clase, tales como denotar que es un detalle de implementación y debe ser utilizado a su cuenta y riesgo.\smallskip

Los métodos y atributos débilmente privados tienen un único guión bajo al principio. Esto señala que son privados, y no deberían ser utilizados por código externo.\smallskip

Sin embargo, es en su mayor parte sólo una convención, y no impide que el código externo los acceda. Su único efecto verdadero es que \ttt{from nombre\_de\_modulo import *} no importará a las variables que empiecen por un único guión bajo.

\section{Métodos de clase}

\section{Métodos estáticos}

\section{Propiedades}

\clearpage\chapter{Expresiones regulares}

\section{Expresiones regulares}

\clearpage\chapter{Empaquetamiento}

\clearpage\chapter{Interfaz gráfica}

\clearpage\chapter{Algoritmos de ordenamiento}

%TODO: introducción

\section{Bubble sort}

Pasos a seguir:

\begin{enumerate}
  \item Se recorre una lista de izquierda a derecha.

  \item Se compara cada par de valores adyacentes.
  
  \item Si dicho par está desordenado (el primero es mayor que el segundo), los cambia de lugar.
  
  \item Esto garantiza que en $n$ iteraciones habrán $n$ elementos ordenados al final de la lista.
  
  \item Se repite hasta obtener la lista ordenada.
  
\end{enumerate}

La forma más simple de programar este algoritmo nos deja con un algoritmo de $O(n^2)$.

\pythonfile{codigo/x-ordenamiento/burbuja.py}
\out{codigo/x-ordenamiento/burbuja.out}

Se puede ver el procedimiento de forma más detallada añadiendo un \ttt{print()} dentro del bucle \ttt{for}.

\pythonfile{codigo/x-ordenamiento/burbuja_detallado.py}
\out{codigo/x-ordenamiento/burbuja_detallado.out}

Para ordenar al revés sólo basta con invertir la condición dentro de la declaración \ttt{if}.

\pythonfile{codigo/x-ordenamiento/burbuja_inverso.py}
\out{codigo/x-ordenamiento/burbuja_inverso.out}

\section{Optimizaciones de bubble sort}

Una pequeña optimización puede ser cambiar el \ttt{range} del segundo \ttt{for} por \ttt{range(N - 1 - i)}. Esto ocurre porque en cualquier iteración siempre habrán \ttt{i} elementos ordenados al final, los cuales se pueden omitir.

\pythonfile{codigo/x-ordenamiento/burbuja_opti_1.py}

Hacer eso sigue manteniendo el algoritmo en $O(n^2)$.\smallskip

Otra optimización es añadir un booleano que revise si han habido cambios en cada iteración. Si en una iteración no hay cambios, significa que ya está ordenado y no es necesario seguir.

\pythonfile{codigo/x-ordenamiento/burbuja_opti_2.py}

Esto hará que el algoritmo sea $O(n^2)$ y $\omega(n)$

\section{Insertion sort}

Pasos a seguir:

\begin{enumerate}
  \item Se recorre una lista de izquierda a derecha.
  
  \item Se compara cada elemento con los elementos a su izquierda, y se mueve a una posición adecuada si no está ordenado.

  \item El primer ordenado siempre estará \doble{ordenado}, ya que no tiene elementos a su izquierda.
  
  \item Se repite hasta tener el último elemento ordenado.
  
\end{enumerate}

La implementación más sencilla de este algoritmo es la siguiente. Tiene una complejidad de $O(n^2)$.

\pythonfile{codigo/x-ordenamiento/insercion.py}
\out{codigo/x-ordenamiento/insercion.out}

Se puede añadir un método \ttt{print()} para ver en más detalle el procedimiento.

\pythonfile{codigo/x-ordenamiento/insercion_detallado.py}
\out{codigo/x-ordenamiento/insercion_detallado.out}

Para ordenar al revés, sólo se debe invertir la condición dentro de la declaración \ttt{if}.

\pythonfile{codigo/x-ordenamiento/insercion_inverso.py}
\out{codigo/x-ordenamiento/insercion_inverso.out}

\section{Selection sort}

Pasos a seguir:

\begin{enumerate}
  \item Se recorre una lista de izquierda a derecha.
  
  \item La lista se \doble{particiona} en 2 listas: uno ordenada (al principio) y otra desordenada (al final).

  \item Se obtiene el elemento más pequeño de la partición desordenada y se mueve a la partición ordenada.
  
  \item Se repite hasta que la partición desordenada esté vacía.
  
\end{enumerate}

A continuación se muestra una implementación de este algoritmo. Tiene complejidad de $O(n^2)$.

\pythonfile{codigo/x-ordenamiento/seleccion.py}
\out{codigo/x-ordenamiento/seleccion.out}

Para ver en detalle como funciona, se puede añadir el método \ttt{print()}.

\pythonfile{codigo/x-ordenamiento/seleccion_detallado.py}
\out{codigo/x-ordenamiento/seleccion_detallado.out}

Al invertir la condición también se invertirá el orden.

\pythonfile{codigo/x-ordenamiento/seleccion_inverso.py}
\out{codigo/x-ordenamiento/seleccion_inverso.out}

%TODO: describir algoritmos

\section{Merge sort}

Este algoritmo generalmente se implementa de forma recursiva. Se basa en \doble{dividir para vencer}, dividiendo un problema complejo en varios más sencillos.\smallskip

Pasos a seguir:

\begin{enumerate}
  \item La lista se divide en mitades, hasta quedar con elementos individuales.
  
  \item Las listas se agrupan por pares, y se empiezan a unir de vuelta.

  \item Al unir las listas, se comparan los primeros elementos de cada una y se añaden a la lista unida. Después de añadirlos, se eliminan de su lista original.
  
  \item Cuando una lista queda vacía, se añaden todos los elementos que queden en su lista pareja a la lista unida.

  \item Se repite hasta llegar a la lista original, la cual quedará ordenada.
  
\end{enumerate}

La siguiente implementación es de $O(n \log{n})$.

\pythonfile{codigo/x-ordenamiento/merge.py}
\out{codigo/x-ordenamiento/merge.out}

Este algoritmo es complicado de entender, ya que usa mucho la recursión. Sin embargo, no es tan complejo como aparenta ser a primera vista.\smallskip

Al igual que los algoritmos anteriores, sólo se necesita invertir una condición para invertir el resultado.

\pythonfile{codigo/x-ordenamiento/merge_inverso.py}
\out{codigo/x-ordenamiento/merge_inverso.out}

%TODO: añadir videos a todo este capitulo

% Big O Notation: https://www.youtube.com/watch?v=__vX2sjlpXU

% Bubble sort: https://www.youtube.com/watch?v=xli_FI7CuzA
% Insertion sort: https://www.youtube.com/watch?v=JU767SDMDvA
% Selection sort: https://www.youtube.com/watch?v=g-PGLbMth_g
% Merge sort: https://www.youtube.com/watch?v=4VqmGXwpLqc
% Heap sort: https://www.youtube.com/watch?v=2DmK_H7IdTo
% Quick sort: https://www.youtube.com/watch?v=Hoixgm4-P4M

\section{Quick sort}

\section{Heap sort}

\clearpage\chapter{Algoritmos de búsqueda}

\section{Búsqueda lineal}

\section{Búsqueda binaria}

\clearpage\chapter{Algoritmos de matrices}

\clearpage\chapter{Implementación de estructuras de datos}

\clearpage\chapter{La librería NumPy}

\end{document}