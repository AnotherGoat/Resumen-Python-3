\chapter{Iterables}

%TODO: iterables https://pythonbasics.org/iterable/

\section{Cortes de lista}

Los cortes de lista ofrecen una manera más avanzada de obtener valores de una lista. Los cortes de lista básicos involucran indexar una lista con dos enteros separados por dos puntos. Esto devuelve una lista nueva que contiene todos los valores de la lista vieja entre los índices.

\pythonfile{codigo/17-iterables/cortes_1.py}
\out{codigo/17-iterables/cortes_1.out}

Como los argumentos de range, el primer índice provisto en un corte es incluido en el resultado, pero el segundo no.\smallskip

Si el primer número en un corte es omitido, se toma el principio de la lista. Si el segundo número es omitido, se toma el final de la lista.

\pythonfile{codigo/17-iterables/cortes_2.py}
\out{codigo/17-iterables/cortes_2.out}

Los cortes de lista también pueden tener un tercer número, representando el incremento, para incluir valores alternativos en el corte.

\pythonfile{codigo/17-iterables/cortes_3.py}
\out{codigo/17-iterables/cortes_3.out}

Los valores negativos pueden ser utilizados en un corte de lista. Cuando los valores negativos son utilizados para el primer y el segundo valor del corte, estos cuentan desde el final de la lista.

\pythonfile{codigo/17-iterables/cortes_4.py}
\out{codigo/17-iterables/cortes_4.out}

El tamaño de paso también puede ser negativo, lo que permite usarlos para invertir listas sin usar el método \ttt{reverse()}.

\pythonfile{codigo/17-iterables/cortes_reverse.py}
\out{codigo/17-iterables/cortes_reverse.out}

Es importante recordar que si el tamaño de paso es negativo, el primer número debe indicar un índice mayor que el segundo.\smallskip

Se pueden usar cortes para copiar listas, aunque no suele ser la forma más clara de hacerlo.

\pythonfile{codigo/17-iterables/copy_cortes.py}
\out{codigo/17-iterables/copy_cortes.out}

\section{Cortes de tuplas}

Los cortes también pueden ser realizados en tuplas. Su funcionamiento es el mismo que con listas.

\pythonfile{codigo/17-iterables/cortes_en_tuplas.py}
\out{codigo/17-iterables/cortes_en_tuplas.out}

Esto es válido porque si bien las tuplas son inmutables, los cortes no realizan ningún cambio sobre los objetos con los que trabajan. Sólo consultan información de cierta manera.

\section{Subcadenas}

En Python pueden usarse cortes para obtener trozos de una cadena. Esto es lo que otros lenguajes de programación realizan usando el método \ttt{substring()}. Funciona de la misma forma que con listas y tuplas.

\pythonfile{codigo/17-iterables/substring_1.py}
\out{codigo/17-iterables/substring_1.out}

%TODO: más

\section{Listas por compresión}

Las listas por compresión son una forma útil de crear rápidamente listas cuyo contenido obedece una regla sencilla.

\pythonfile{codigo/17-iterables/compresion_1.py}
\out{codigo/17-iterables/compresion_1.out}

%TODO: enlace a constructores de conjuntos
Las listas por compresión son inspiradas por la notación de constructores de conjuntos en las matemáticas.\smallskip

Una lista por compresión también puede contener una sentencia \ttt{if} para aplicar una condición en los valores de la lista.

\pythonfile{codigo/17-iterables/compresion_2.py}
\out{codigo/17-iterables/compresion_2.out}

Intentar crear una lista de rango demasiado extenso resultará en un \ttt{MemoryError}. Es posible que la operación tarde unos minutos en llegar a esta excepción, o que el PC se quede sin memoria antes de que llegue a aparecer.

\pythonfile{codigo/17-iterables/compresion_3.py}

Se debe recordar que se puede interrumpir la ejecución del programa en cualquier momento enviando un \ttt{KeyboardInterrupt}, al pulsar \ttt{Ctrl+C}.\smallskip

Este problema de memoria es resuelto con generadores, los cuales se verán más tarde.

\section{Formateo de cadenas}

La forma más básica de combinar cadenas y objetos que no son cadenas es convirtiendo dichos objetos a cadenas y concatenando las cadenas.\smallskip

El formateo de cadenas ofrece una manera más potente de incorporar objetos que no son cadenas a las cadenas. El formateo de cadenas utiliza el método \ttt{format()} de una cadena para sustituir los argumentos de esta.\smallskip

Una forma de hacerlo es usando índices.

\pythonfile{codigo/17-iterables/formateo_1.py}
\out{codigo/17-iterables/formateo_1.out}

Cada argumento de la función de formateo es colocada en la cadena de la posición correspondiente, que es determinada usando llaves \ttt{\{\}}.\smallskip

Los índices entre llaves \ttt{\{\}} pueden repetirse cuantas veces se quiera.

\pythonfile{codigo/17-iterables/formateo_2.py}
\out{codigo/17-iterables/formateo_2.out}

Si se omite un índice, habrá algún argumento de \ttt{format()} que no se usará.

\pythonfile{codigo/17-iterables/formateo_3.py}
\out{codigo/17-iterables/formateo_3.out}

No es necesario escribir los índices dentro de las llaves {}, pero esto no permite que se repitan o que se entreguen como argumentos en otro orden.

\pythonfile{codigo/17-iterables/formateo_4.py}
\out{codigo/17-iterables/formateo_4.out}

El formateo de cadenas también puede hacerse con argumentos con nombre.

\pythonfile{codigo/17-iterables/formateo_5.py}
\out{codigo/17-iterables/formateo_5.out}

\section{Funciones de cadenas}

Python contiene muchas funciones integradas y métodos útiles que sirven para cumplir tareas comunes. Algunos métodos que se pueden usar con strings son:

\begin{itemize}
  \item join(): Combina una lista de cadenas con otra cadena como separador.
  
  \pythonfile{codigo/17-iterables/join.py}
  \out{codigo/17-iterables/join.out}

  \item replace(): Reemplaza una subcadena de una cadena por otra cadena.

  \pythonfile{codigo/17-iterables/replace.py}
  \out{codigo/17-iterables/replace.out}

  \item startswith(): Determina si hay una subcadena al principio de una cadena.

  \pythonfile{codigo/17-iterables/startswith.py}
  \out{codigo/17-iterables/startswith.out}

  \item endswith(): Determina si hay una subcadena al final de una cadena.
  
  \pythonfile{codigo/17-iterables/endswith.py}
  \out{codigo/17-iterables/endswith.out}

  \item A diferencia de otros lenguajes de programación, Python no tiene el método contains(), para ver si una subcadena pertenece a un string.\smallskip
  
  Usar el operador in tiene el mismo efecto que tendría dicha función.

  %TODO: contains (if x in string)

  \item upper(): Cambia una cadena a mayúsculas.
  
  \pythonfile{codigo/17-iterables/upper.py}
  \out{codigo/17-iterables/upper.out}

  \item lower(): Cambia una cadena a minúsculas.
  
  \pythonfile{codigo/17-iterables/lower.py}
  \out{codigo/17-iterables/lower.out}

  \item capitalize(): Cambia una cadena para que la primera letra sea mayúscula y el resto minúsculas.

  \pythonfile{codigo/17-iterables/capitalize.py}
  \out{codigo/17-iterables/capitalize.out}
  
  \item title(): Cambia una cadena para que todas las palabras empiecen con mayúscula.
  
  \pythonfile{codigo/17-iterables/title.py}
  \out{codigo/17-iterables/title.out}

\end{itemize}

Al método \ttt{split()} te visto anteriormentambién se le puede entregar un string separador. La lista será formada con los elementos entre cada aparición de ese string.

\pythonfile{codigo/6-listas/split_avanzado.py}
%TODO: out y rehacer el ejemplo

\section{Funciones all() y any()}

Las funciones \ttt{all()} y \ttt{any()} son utilizados con frecuencia como sentencias condicionales. Estos toman una lista como un argumento y devuelven True si todos o algunos (respectivamente) de sus argumentos son evaluados como True (o, de lo contrario, False).

\pythonfile{codigo/17-iterables/all.py}
\out{codigo/17-iterables/all.out}

\pythonfile{codigo/17-iterables/any.py}
\out{codigo/17-iterables/any.out}

\section{Función enumerate()}

La función \ttt{enumerate()} se usa para iterar a través de los valores e índices de una lista, simultáneamente.

\pythonfile{codigo/17-iterables/enumerate_1.py}
\out{codigo/17-iterables/enumerate_1.out}

También se puede especificar el índice desde el que comienza.

\pythonfile{codigo/17-iterables/enumerate_2.py}
\out{codigo/17-iterables/enumerate_2.out}

\clearpage