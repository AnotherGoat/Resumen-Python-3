\chapter{Programación funcional}

\Needspace{8\baselineskip}
\section{Paradigma de programación funcional}

La programación funcional es un estilo de programación que, como dice su nombre, gira en torno a funciones.

Una parte clave de la programación funcional son las funciones de orden superior.
Similar al uso de funciones como objetos, las funciones de orden superior reciben otras funciones como argumentos, o las devuelven como resultado.

\pythonfile{codigo/funcional/ejemplo_funcional.py}
\out{codigo/funcional/ejemplo_funcional.out}

La función \ttt{repetir\_2\_veces()} mostrada en el ejemplo recibe otra función como su argumento y la llama 2 veces dentro de su cuerpo.

Entender los conceptos de programación funcional requiere un conocimiento básico del concepto algebraico llamado \link{https://www.mathsisfun.com/sets/functions-composition.html}{\doble{composición de funciones}}.

\Needspace{8\baselineskip}
\section{Funciones puras}

La programación funcional busca utilizar funciones puras.
Las funciones puras no tienen efectos secundarios y devuelven un valor que depende únicamente de sus argumentos.

Así son las funciones en las matemáticas.
Por ejemplo, la función $\cos{x}$ siempre devolverá el mismo resultado para el mismo valor de $x$.

Ejemplo de función pura:

\pythonfile{codigo/funcional/pura.py}

Ejemplo de función impura:

\pythonfile{codigo/funcional/impura.py}

Dicho de otra forma, una función pura cumple lo siguiente:

\begin{itemize}
  \item Depende sólo de sus argumentos y de variables locales creadas dentro de ella.
  
  \item Siempre retorna el mismo resultado para los mismos argumentos.

  \item Se puede ejecutar en cualquier parte del programa sin causar efectos secundarios de ningún tipo.
  
  \item No altera ningún elemento fuera de ella.
  
  \item Puede usarse en otros programas y entrega los mismos resultados.
  
\end{itemize}

Utilizar funciones puras tiene sus ventajas y desventajas.

Las funciones puras son:

\begin{itemize}
  \item Más fáciles de analizar y probar.
  
  \item Más eficientes.
  Una vez que la función haya sido evaluada para una entrada, el resultado puede ser almacenado y referenciado para la próxima vez que la función con esa entrada sea necesaria, reduciendo el número de veces que la función es llamada.
  Esto se denomina memorización.
  
  \item Más fáciles de ejecutar en paralelo.
  
\end{itemize}

Desventajas principales:

\begin{itemize}
  \item Complican en su mayor parte la normalmente sencilla tarea de Entrada/Salida, ya que requiere de efectos secundarios inherentemente.
  
  \item En algunas situaciones, pueden ser más difíciles de escribir.
  
\end{itemize}

\Needspace{8\baselineskip}
\section{Lambdas}

Crear una función normalmente (utilizando \ttt{def}) le asigna una variable automáticamente.

Esto es distinto a la creación de otros objetos, tales como cadenas y enteros, que pueden ser creados en el camino, sin la necesidad de asignarles una variable.

Lo mismo es posible con las funciones, dado que sean creadas utilizando la sintaxis \ttt{lambda}.
Funciones creadas de esta forma son conocidas como anónimas.

Este enfoque es más comúnmente utilizado cuando se pasa una función sencilla como argumento de otra función.

La sintaxis que se muestra a continuación consiste de la palabra reservada lambda seguida de una lista de argumentos, dos puntos, y una expresión a evaluar y devolver.

\pythonfile{codigo/funcional/lambda_1.py}
\out{codigo/funcional/lambda_1.out}

Las funciones \ttt{lambda} reciben su nombre del \link{https://es.wikipedia.org/wiki/C\%C3\%A1lculo_lambda}{cálculo lambda}, el cual es un modelo computacional inventado por Alonzo Church.

Las funciones lambda no son tan potentes como las funciones con nombre.
Sólo pueden hacer cosas que requieren de una sola expresión, normalmente equivalente a una sola línea de código.

\pythonfile{codigo/funcional/lambda_2.py}
\out{codigo/funcional/lambda_2.out}

Las funciones \ttt{lambda} pueden ser asignadas a variables y ser utilizadas como funciones regulares.

\pythonfile{codigo/funcional/lambda_3.py}
\out{codigo/funcional/lambda_3.out}

Sin embargo, rara vez existe una buena razón para hacer esto.
Normalmente es mejor definir una función con \ttt{def}.

\Needspace{8\baselineskip}
\section{Función map()}

La función \ttt{map()} es una función de orden superior muy útil que opera sobre listas (u objetos similares llamados iterables).

Esta función recibe una función y un iterable como argumentos y devuelve un nuevo iterable con la función aplicada a cada argumento.

\pythonfile{codigo/funcional/map_1.py}
\out{codigo/funcional/map_1.out}

El mismo resultado se puede obtener con mayor facilidad utilizando la sintaxis \ttt{lambda}.

\pythonfile{codigo/funcional/map_2.py}
\out{codigo/funcional/map_2.out}

Los objetos del tipo mapa son iterables, por lo que se debe usar \ttt{list()} para convertir el resultado en una lista y poder verlo.

\Needspace{8\baselineskip}
\section{Función filter()}

La función \ttt{filter()} es otra función de orden superior que se puede usar sobre iterables.

Esta función filtra un iterable eliminando elementos que no coincidan con el predicado (una función que devuelve un booleano).

\pythonfile{codigo/funcional/filter.py}
\out{codigo/funcional/filter.out}

Al igual que \ttt{map()}, el resultado tiene que ser convertido explícitamente a una lista si se quiere imprimir.

\Needspace{8\baselineskip}
\section{Generadores}

Los generadores son un tipo de iterable, como las listas o las tuplas.

A diferencia de las listas, no permiten indexar con índices arbitrarios, pero pueden aún ser iterados con bucles \ttt{for}.

Pueden ser creados utilizando funciones y la sentencia \ttt{yield}.

\pythonfile{codigo/funcional/generador_1.py}
\out{codigo/funcional/generador_1.out}

Nótese que si en el ejemplo anterior no se hubiera especificado la condición de salida, hubiera seguido contando infinitamente en los negativos y tendría que detenerse pulsando \ttt{Ctrl+C}.

La sentencia yield es utilizada para definir un generador, reemplazando el retorno de una función para proveer un resultado a su llamador sin destruir las variables locales.

Debido al hecho que \ttt{yield} produce un elemento a la vez, los generadores no tienen las restricciones de memoria de las listas.
De hecho, ¡pueden ser infinitos!

\pythonfile{codigo/funcional/generador_2.py}
\out{codigo/funcional/generador_2.out}

En resumen, los generadores permiten declarar una función que se comporta como un iterador.
En otras palabras, que puede utilizarse en un bucle \ttt{for}.

Un ejemplo de uso de generadores es para generar números primos.
%TODO: más ejemplos

\pythonfile{codigo/funcional/generador_de_primos.py}
\out{codigo/funcional/generador_de_primos.out}

Los generadores finitos pueden ser convertidos en listas al pasarlos como argumentos de la función \ttt{list()}.

\pythonfile{codigo/funcional/generador_a_lista.py}
\out{codigo/funcional/generador_a_lista.out}

Utilizar generadores resulta en un mejor rendimiento, el cual es el resultado de una generación ociosa de valores (a medida que se vayan necesitando), lo cual se traduce en un uso reducido de memoria.
Es más, no necesitamos esperar hasta que todos los elementos sean generados antes de empezar a utilizarlos.

\Needspace{8\baselineskip}
\section{Decoradores}

Los decoradores ofrecen una forma de modificar funciones utilizando otras funciones.
Esto es ideal cuando se necesita extender la funcionalidad de funciones que no se quieren modificar.

\pythonfile{codigo/funcional/decorador_1.py}
\out{codigo/funcional/decorador_1.out}

En este caso, el uso la función \ttt{envolver()} se define dentro de \ttt{decor()} para permitir que \ttt{decor()} retorne una función, que es el objetivo principal de un decorador.
La función \ttt{texto\_decorado()} es una versión decorada de la función \ttt{imprimir\_texto()}.

De hecho, si se escribiera un decorador útil, podría reemplazarse \ttt{imprimir\_texto()} por su versión decorada.

\pythonfile{codigo/funcional/decorador_2.py}
\out{codigo/funcional/decorador_2.out}

En el ejemplo anterior, se decora la función \ttt{imprimir\_texto()} reemplazando la variable que contiene la función por una versión envuelta.

\pythonfile{codigo/funcional/decorador_3.py}

Este patrón puede utilizarse en cualquier momento, para envolver cualquier función.

Python ofrece apoyo para envolver una función en un decorador anteponiendo la definición de la función con el nombre de un decorador y el símbolo \ttt{\@}, lo cual tendrá el mismo resultado que el código de arriba.

\pythonfile{codigo/funcional/decorador_4.py}

Una sola función puede tener varios decoradores y cada decorador puede repetirse más de una vez.

\pythonfile{codigo/funcional/decorador_5.py}
\out{codigo/funcional/decorador_5.out}

Los decoradores pueden ser usados para muchos otros propósitos además de \doble{decorar}.
El siguiente ejemplo muestra un decorador que añade la petición de entrada a funciones que no la tienen.

\pythonfile{codigo/funcional/decorador_entrada.py}

Un ejemplo aún más útil es un decorador para medir el tiempo que tarda en ejecutarse un algoritmo.

\pythonfile{codigo/funcional/decorador_tiempo.py}
\out{codigo/funcional/decorador_tiempo.out}

\Needspace{8\baselineskip}
\section{Recursión}

La recursión es un concepto muy importante en la programación funcional.

Lo fundamental de la recursión es la autorreferencia, funciones que se llaman a sí mismas.
Se utiliza para resolver problemas que pueden ser divididos en subproblemas más sencillos del mismo tipo.

Un ejemplo clásico de una función que es implementada recursiva es la función factorial.

\pythonfile{codigo/funcional/factorial.py}
\out{codigo/funcional/factorial.out}

El caso base \ttt{n == 0} actúa como condición de salida de la recursión, porque no involucra más llamadas a la función.

Las funciones recursivas pueden ser infinitas, al igual que los bucles \ttt{while}.
Estas ocurren cuando se olvida implementar algún caso base.

Abajo se muestra una versión incorrecta de la función factorial.
No tiene caso base, así que se ejecutaría hasta que al interpretador se le acabe la memoria o se cuelgue, pero por suerte, el intérprete de Python es inteligente y levantará un \ttt{RecursionError}.

\pythonfile{codigo/funcional/factorial_malo.py}
\out{codigo/funcional/factorial_malo.out}

La recursión también puede ser indirecta.
Una función puede llamar a una segunda, que a su vez llama a la primera, que llama a la segunda, y así sucesivamente.
Esto puede ocurrir con cualquier cantidad de funciones.

\pythonfile{codigo/funcional/par_o_impar.py}
\out{codigo/funcional/par_o_impar.out}

Otro ejemplo clásico es la serie de Fibonacci.

\pythonfile{codigo/funcional/fibonacci.py}
\out{codigo/funcional/fibonacci.out}

\Needspace{8\baselineskip}
\section{Iteración vs. Recursión}

%TODO: más ejemplos de generadores aquí

\Needspace{8\baselineskip}
\section{Generadores recursivos}

% yield from

\clearpage